---
title: C++20 落穂拾い
author: onihusube
date: 2024/08/12
geometry:
  width: 188mm
  height: 263mm
#coverimage: cover.jpg
#backcoverimage: backcover.jpg
titlecolor:
  color1:
    r: 0.7882
    g: 0.6745
    b: 0.9092
    c: 0.25
    m: 0.3
    y: 0.0
    k: 0.0
  color2:
    r: 0.6
    g: 0.0
    b: 0.6
    c: 0.3
    m: 0.95
    y: 0.0
    k: 0.0
okuduke:
  revision: 初版
  printing: ねこのしっぽ
---
\clearpage

# はじめに

本書は既発行の『C++20 コア言語機能』『C++20 ranges』『C++20 ライブラリ機能1, 2』などで時間の制約などの都合で扱っていなかったトピックについて解説するものです。

## 注意など

本書はC++20をベースとして記述されています。そのため、C++17までに導入されている機能については特に導入バージョンについて触れず、知っているものとして詳しい解説なども行いません。また、C++20の他の機能に関しても、すでに以前の書籍で説明済みのものは知っているものとして使用します。そちらの説明は以前発行の書籍（『C++20 コア言語機能』『C++20 ranges』『C++20 ライブラリ機能1, 2』）もしくはcpprefjpなどの解説サイトを参照してください。

## サンプルコードのお約束

- そこで主題となっているライブラリ機能のためのヘッダのみを明示的にインクルードし、他のヘッダのインクルードは省略します
- 主題と関係ないところを`...`で省略していることがあります
- 行の末尾コメントで`ok/ng`と表示することで、それがコンパイル可能かどうかを示しています。`// ok`はコンパイルが通り未定義動作がないこと、`// ng`はコンパイルエラーとなる事をそれぞれ表しています
- 本文中でメンバ関数を表記する際、`.menber_func()`のように先頭に`.`を付加して区別しています

コードブロック中で標準出力をしている時、直後のブロックでその出力例を示していることがあります。例えば次のようになっています

```cpp
int main() {
  std::cout << "hello world!";
}
```
```{style=planetext}
hello world!
```

　

標準ライブラリ中での宣言を例示する際、コードブロックの見た目を分けて表示しています（上と左の線が二重線 + 角丸）。例えば次のようになっています

```{style=cppstddecl}
// std::vectorの宣言例
namespace std {
  template<class T, class Allocator = allocator<T>>
  class vector;
}
```

\clearpage

# コンセプトの半順序、もう少し

コア言語機能本のコンセプトの章では、コンセプトによるオーバーロード解決時の順序付けについて`&&`のもののみを説明して`||`の場合を省略していました。ここでは`||`が入ってくる場合を少しだけ覗いてみます。

## `||`だけからなる制約式における順序付け

`&&`だけからなる場合の制約の順序は、`&&`で繋がれている制約を集めて来た時、片方の関数の制約の集合がもう片方の関数の制約の集合に完全に包含されている場合に包含している方がより制約されているとして、より優先的に選択されていました。

```cpp
template<std::copyable T>
void f(T);  // (1) copyableのみ

template<std::copyable T>
  requires std::convertible_to<T, int>
void f(T);  // (2) copyable + convertible_to

int main() {
  int n = 10;

  f(n);  // (2)が呼ばれる
}
```

`||`の場合も同様にコンセプトの包含関係を考えることで順序をとらえることができますが、その考え方は`&&`とは逆に制約の包含関係が成り立っている場合は包含されている方がより優先順位が高くなります。

```cpp
template<typename T>
  requires std::integral<T>
void f(T);   // (1) integralのみ
template<typename T>
  requires std::integral<T> || std::floating_point<T>
void f(T);   // (2) integral + floating_point

int main() {
  f(10);  // (1)が呼ばれる
  f(1.0); // (2)が呼ばれる
}
```

2つの関数オーバーロードAとBの間の制約の包含関係は、`||`でつながれている原子制約について、一方の関数（A）の全ての原子制約が他方の関数（B）の制約に全て現れていて、かつ他方（B）はそれに加えてさらに制約されている（`||`によって）時、A ⊂ Bの制約の包含関係が成立します（ここまでは`&&`と同じ）。しかし、`||`の場合は包含されている方がより制約されているとしてA > B（AがBより順位が高い）の順序付けがなされます。そして、どちらのオーバーロードもコンセプト以外の部分での順序付けが同等となる場合、より制約されている方のオーバーロードが優先的に選択されます。

上記の例では`f(10)`の呼び出しに対して、(1)も(2)も`std::integral<T>`コンセプトを満たすためどちらも制約を満たすことになりオーバーロード候補として残ります。その際、(2)は`integral<T>`に加えて`floating_point<T>`によっても制約がなされており、同じ`T`に対して(1)の制約は(2)の制約によって完全に包含されており、その包含関係とは逆に(1)のほうが(2)よりも優先順位が高くなります。

ただし、上記`f(1.0)`のように片方のオーバーロードの制約を満たさないことでオーバーロード解決が発生しない場合は制約の包含関係は関係なく残った1つの候補が選択されます。これは`||`に対する直感通りの結果でしょう。

この`||`の場合の制約の包含関係は、`||`で繋がれた中に満たされていない（`false`となっている）コンセプトがあるかどうかは関係がありません。`||`の場合は1つでも満たしていれば全体の制約が満たされるため、それによってオーバーロード解決が発生する場合のコンセプトの包含関係は制約の全体によって考慮されます。例えば次のように`||`の両辺の制約を満たしている場合でも、より制約の少ない方が優先的に選択されます。

```cpp
template<typename T>
  requires std::integral<T>
void f(T);   // (1)
template<typename T>
  requires std::integral<T> || std::same_as<T, int>
void f(T);   // (2)

int main() {
  int n = 10;
  f(n);  // (1)が呼ばれる
}
```

別の言い方をすると、`||`だけが使用されて制約されている関数オーバーロードAとBそれぞれの原子制約を要素とする2つの集合があった時、その間に成立する包含関係（片方は他方の真部分集合）を逆転させたものがコンセプトの包含関係となります。そして、そのような包含関係が成り立たない時は順序付け不可能となり、2つの関数オーバーロードの呼び出しは曖昧となります。



## `||`と`&&`が混在する場合の順序付け

## 結論

`||`が入ってくる場合のコンセプトの順序付けについて詳しく説明しましたが、結論は変わりません。単純な場合を除いて、`||`による制約はなるべき使用しない方が良いでしょう…

# 一貫比較仕様、比較演算子の合成について

# `<chrono>`のスキップしたもの

## `hhmmss`

## タイムゾーンデータベース

# `consteval`コンストラクタによるコンパイル時検査について

# 謝辞

本書を執筆するに当たっては以下のサイトをとても参照しました。サイト管理者及び編集者・執筆者の方々に厚く御礼申し上げます。

- cpprefjp(https://cpprefjp.github.io/ : ライセンスはCC-BY 3.0)
- cppreference(https://ja.cppreference.com/w/cpp : ライセンスはCC-BY-SA 3.0)
- Compiler Explorer(https://godbolt.org/)

また、大阪C++読書会において以前に発行したC++20コア言語機能及びC++20ライブラリ機能1を輪読していただき、感想等のフィードバックを頂いております。モチベーションになっています、ありがとうございます！

- [大阪C++読書会 - connpass](https://cpp-osaka.connpass.com/ )
- [大阪C++読書会 - scrapbox](https://scrapbox.io/cpp-osaka/ )
