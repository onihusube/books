---
title: C++20 落穂拾い
author: onihusube
date: 2024/08/12
geometry:
  width: 188mm
  height: 263mm
#coverimage: cover.jpg
#backcoverimage: backcover.jpg
titlecolor:
  color1:
    r: 0.7882
    g: 0.6745
    b: 0.9092
    c: 0.25
    m: 0.3
    y: 0.0
    k: 0.0
  color2:
    r: 0.6
    g: 0.0
    b: 0.6
    c: 0.3
    m: 0.95
    y: 0.0
    k: 0.0
okuduke:
  revision: 初版
  printing: ねこのしっぽ
---
\clearpage

# はじめに

本書は既発行の『C++20 コア言語機能』『C++20 ranges』『C++20 ライブラリ機能1, 2』などで時間の制約などの都合で扱っていなかったトピックについて解説するものです。

## 注意など

本書はC++20をベースとして記述されています。そのため、C++17までに導入されている機能については特に導入バージョンについて触れず、知っているものとして詳しい解説なども行いません。また、C++20の他の機能に関しても、すでに以前の書籍で説明済みのものは知っているものとして使用します。そちらの説明は以前発行の書籍（『C++20 コア言語機能』『C++20 ranges』『C++20 ライブラリ機能1, 2』）もしくはcpprefjpなどの解説サイトを参照してください。

## サンプルコードのお約束

- そこで主題となっているライブラリ機能のためのヘッダのみを明示的にインクルードし、他のヘッダのインクルードは省略します
- 主題と関係ないところを`...`で省略していることがあります
- 行の末尾コメントで`ok/ng`と表示することで、それがコンパイル可能かどうかを示しています。`// ok`はコンパイルが通り未定義動作がないこと、`// ng`はコンパイルエラーとなる事をそれぞれ表しています
- 本文中でメンバ関数を表記する際、`.menber_func()`のように先頭に`.`を付加して区別しています

コードブロック中で標準出力をしている時、直後のブロックでその出力例を示していることがあります。例えば次のようになっています

```cpp
int main() {
  std::cout << "hello world!";
}
```
```{style=planetext}
hello world!
```

　

標準ライブラリ中での宣言を例示する際、コードブロックの見た目を分けて表示しています（上と左の線が二重線 + 角丸）。例えば次のようになっています

```{style=cppstddecl}
// std::vectorの宣言例
namespace std {
  template<class T, class Allocator = allocator<T>>
  class vector;
}
```

\clearpage

# コンセプトの半順序、もう少し

コア言語機能本のコンセプトの章では、コンセプトによるオーバーロード解決時の順序付けについて`&&`のもののみを説明して`||`の場合を省略していました。ここでは`||`が入ってくる場合を少しだけ覗いてみます。

## `||`だけからなる制約式における順序付け

`&&`だけからなる場合の制約の順序は、`&&`で繋がれている制約を集めて来た時、片方の関数の制約の集合がもう片方の関数の制約の集合に完全に包含されている場合に包含している方がより制約されているとして、より優先的に選択されていました。

```cpp
template<std::copyable T>
void f(T);  // (1) copyableのみ

template<std::copyable T>
  requires std::convertible_to<T, int>
void f(T);  // (2) copyable + convertible_to

int main() {
  int n = 10;

  f(n);  // (2)が呼ばれる
}
```

`||`の場合も同様にコンセプトの包含関係を考えることで順序をとらえることができますが、その考え方は`&&`とは逆に制約の包含関係が成り立っている場合は包含されている方がより優先順位が高くなります。

```cpp
template<typename T>
  requires std::integral<T>
void f(T);   // (1) integralのみ
template<typename T>
  requires std::integral<T> || std::floating_point<T>
void f(T);   // (2) integral + floating_point

int main() {
  f(10);  // (1)が呼ばれる
  f(1.0); // (2)が呼ばれる
}
```

2つの関数オーバーロードAとBの間の制約の包含関係は、`||`でつながれている原子制約について、一方の関数（A）の全ての原子制約が他方の関数（B）の制約に全て現れていて、かつ他方（B）はそれに加えてさらに制約されている（`||`によって）時、A ⊂ Bの制約の包含関係が成立します（ここまでは`&&`と同じ）。しかし、`||`の場合は包含されている方がより制約されているとしてA > B（AがBより順位が高い）の順序付けがなされます。そして、どちらのオーバーロードもコンセプト以外の部分での順序付けが同等となる場合、より制約されている方のオーバーロードが優先的に選択されます。

上記の例では`f(10)`の呼び出しに対して、(1)も(2)も`std::integral<T>`コンセプトを満たすためどちらも制約を満たすことになりオーバーロード候補として残ります。その際、(2)は`integral<T>`に加えて`floating_point<T>`によっても制約がなされており、同じ`T`に対して(1)の制約は(2)の制約によって完全に包含されており、その包含関係とは逆に(1)のほうが(2)よりも優先順位が高くなります。

ただし、上記`f(1.0)`のように片方のオーバーロードの制約を満たさないことでオーバーロード解決が発生しない場合は制約の包含関係は関係なく残った1つの候補が選択されます。これは`||`に対する直感通りの結果でしょう。

この`||`の場合の制約の包含関係は、`||`で繋がれた中に満たされていない（`false`となっている）コンセプトがあるかどうかは関係がありません。`||`の場合は1つでも満たしていれば全体の制約が満たされるため、それによってオーバーロード解決が発生する場合のコンセプトの包含関係は制約の全体によって考慮されます。例えば次のように`||`の両辺の制約を満たしている場合でも、より制約の少ない方が優先的に選択されます。

```cpp
template<typename T>
  requires std::integral<T>
void f(T);   // (1)
template<typename T>
  requires std::integral<T> || std::same_as<T, int>
void f(T);   // (2)

int main() {
  int n = 10;
  f(n);  // (1)が呼ばれる
}
```

別の言い方をすると、`||`だけが使用されて制約されている関数オーバーロードAとBそれぞれの原子制約を要素とする2つの集合があった時、その間に成立する包含関係（片方は他方の真部分集合）を逆転させたものがコンセプトの包含関係となります。そして、そのような包含関係が成り立たない時は順序付け不可能となり、2つの関数オーバーロードの呼び出しは曖昧となります。

```cpp
template<typename T>
concept A = /*...*/;

template<typename T>
concept B = /*...*/;

template<typename T>
concept C = /*...*/;

template<typename T>
concept D = /*...*/;

template<typename T>
  requires A<T>
void f(T); // (1)

template<typename T>
  requires A<T> || B<T>
void f(T); // (2)

template<typename T>
  requires A<T> || B<T> || C<T>
void f(T); // (3)

template<typename T>
  requires A<T> || B<T> || D<T>
void f(T); // (4)
```

この時、各`f()`の制約の包含関係は(1) ⊂ (2) ⊂ (3)となり、(1) > (2) > (3)の順で優先順位が付きます。また、(1) ⊂ (2) ⊂ (4)の包含関係も成立しているため、(1) > (2) > (4)の優先順位も付きます。 一方、(3)と(4)の制約の間にはお互いに包含関係が成立しない（`C`は(4)の制約に現れず、`D`は(3)の制約に現れない）ため順序が付きません。したがって、(3)と(4)の間ではオーバーロード解決が曖昧となります。

この例のような`f<T>()`の呼び出しにおいて、`T`が`A, B, C`の制約をすべて満たす場合は(1)のオーバーロードが呼ばれます（このとき`D`を満たしていても呼び出しは曖昧になりません）。同様に、`T`が`A, B, D`の制約をすべて満たす場合も(1)のオーバーロードが呼ばれます（`C`を満たしていても）。`T`が`B`だけを満たす場合は(2)が呼ばれ、`T`が`C`だけを満たす場合は(3)が呼ばれ、`T`が`D`だけを満たす場合は(4)が呼ばれます。

一方、`T`が`C`と`D`だけを満たす場合は(3)と(4)の間に順序がつかないため呼び出しは曖昧となりエラーになります。

## `||`と`&&`が混在する場合の順序付け

コンセプトが`&&`だけ、あるいは`||`だけによって構成されている場合は比較的簡単にその順序を理解することができます。しかし、次のような場合はどうでしょう？

```cpp
template<typename T>
concept A = /*...*/;

template<typename T>
concept B = /*...*/;

template<typename T>
concept C = /*...*/;

template<typename T>
concept D = /*...*/;

template<typename T>
  requires ((A<T> && B<T>) || C<T>) && D<T>
void f(); // (1)

template<typename T>
  requires A<T> || D<T>
void f(); // (2)
```

全てのコンセプトを満たすような`T`の入力に対して、どちらのオーバーロードが呼ばれるか分かるでしょうか？これまでのような制約の包含関係の延長でこれを理解するのは無理そうです。これはコンパイラにとっても同様なため、標準ではこのような複雑な制約の間でも順序判定が可能な方法を指定しています。

2つのオーバーロード間の制約を比較する時、1つ目のオーバーロードの制約全体を`P`、2つ目のオーバーロードの制約全体を`Q`として、`P`が`Q`より制約されているかどうかを判定する手順は次のようになります

1. `P`を選言標準形、`Q`を連言標準形に変換する
    - 選言標準形は、`()`で囲まれた`&&`の制約を`||`で接続した形の制約
    - 連言標準形は、`()`で囲まれた`||`の制約を`&&`で接続した形の制約
2. `P`の選言標準形の各項（部分式）`Pi`と`Q`の連言標準形の各項`Qj`を比較する
    - `Pi`は必ず`&&`だけからなる制約となっている
    - `Qj`は必ず`||`だけからなる制約となっている
3. それぞれの`Pi`と`Qj`の比較においては、さらにそれの各項`Pia`と`Qjb`を比較し、`Pia`と`Qjb`が同じコンセプトによる制約になっている組が1つでもあれば、`Pi`は`Qj`よりも制約されている（`Pi > Qj`）となる
4. `P`の選言標準形の全ての項`Pi`が`Q`の連言標準形の全ての項`Qj`よりも制約されている場合に、`P`は`Q`よりも制約されている（`P > Q`）となる

よっぽど数理論理学に精通しているわけでもなければ、これを見てなるほど！とは思わないと思います。まず1に出てくる選言標準形と連言標準形から聞きなれないでしょう。

選言標準形は制約を分配法則や結合法則によって変換して、`&&`による制約を`||`でつないだ形に変換したものです。同様に、連言標準形は`||`による制約を`&&`でつないだ形に変換したものです。

分配法則や結合法則は論理和と論理積（$\lor, \land$）に成り立つものを$\lor$を`||`に$\land$を`&&`に対応させて使用することができます。

```
// 分配法則
A || (B && C) <=> (A || B) && (A || C)
A && (B || C) <=> (A && B) || (A && C)

// 結合法則
A || (B || C) <=> (A || B) || C
A && (B && C) <=> (A && B) && C
```

これを用いてあらゆる制約は選言標準形と連言標準形の両方に変換することができます。

いきなり論理和や論理積が出てきたことから分かるかもしれませんが、選言標準形や連言標準形という言葉もそちらの数理論理学の文脈から来ています。任意の制約がこの2つの標準形に変換可能であることも論理式において同様のことが成り立つことによって保証されています。

論理式における選言・連言標準形への変換では、次の3ステップによって機械的に変形できることが知られています

1. $\to$と$\iff$を同値変形によって論理和と論理積のみからなる式に変形する
2. ド・モルガンの法則、二重否定除去規則を適用する
3. 分配法則によって、選言標準形の場合`&&`を、連言標準形の場合`||`を`()`の中へ移動する

各ステップにおいてはそれぞれのステップでの操作が適用できなくなるまでそれを繰り返します。

とはいえコンセプトの制約式においては1のステップは関係ありません。2のステップに関しては、後述するように否定（`!`）の存在については注意が必要となり、否定は全てコンセプトの中に入れるようにすると不要になります。結局、3のステップが重要となります。

例として、`(a1 && a2) || (a3 && (a4 || (a5 && a6)))`という制約式を変形すると

選言標準形の場合

```
  (a1 && a2) || (a3 && (a4 || (a5 && a6)))
= (a1 && a2) || ((a3 && a4) || (a3 && (a5 && a6)))
= (a1 && a2) || ((a3 && a4) || (a3 && a5 && a6))
= (a1 && a2) || (a3 && a4) || (a3 && a5 && a6)
```

連言標準形の場合

```
  (a1 && a2) || (a3 && (a4 || (a5 && a6)))
= (a1 && a2) || (a3 && ((a4 || a5) && (a4 || a6)))
= (a1 && a2) || (a3 && (a4 || a5) && (a4 || a6))
= (a1 || a3) && (a1 || a4 || a5) && (a1 || a4 || a6) &&
  (a2 || a3) && (a2 || a4 || a5) && (a2 || a4 || a6)
```

となります。ここでの変形には上記の分配法則と結合法則だけを使用しています。

少し脱線しましたがともかく、同様にして任意の制約式は選言標準形にも連言標準形にも変形することができます。

制約の比較手順に戻って、2番目の手順で使用される選言・連言標準形の各項というのは、選言標準形の場合は`||`で繋がれた各項のことで、連言標準形の場合は`&&`で繋がれた各項の事です。先程の例で計算した選言標準形`(a1 && a2) || (a3 && a4) || (a3 && a5 && a6)`だと、`(a1 && a2), (a3 && a4), (a3 && a5 && a6)`の3つの部分式がそれにあたり、連言標準形`(a1 || a3) && (a1 || a4 || a5) && (a1 || a4 || a6) && (a2 || a3) && (a2 || a4 || a5) && (a2 || a4 || a6)`だと`(a1 || a3), (a1 || a4 || a5), (a1 || a4 || a6), (a2 || a3), (a2 || a4 || a5), (a2 || a4 || a6)`の6つの部分式がそれにあたります。

この部分式をよく見ると、選言標準形の場合は各項の制約式は必ず`&&`だけからなり、連言標準形の場合は各項の制約式は必ず`||`だけからなっています。わざわざ標準形に変換するのはこのことが重要だからです。

これらの各項（部分式）は再帰的に部分式を持ち、それが手順の3番目で使用されている`Pia, Qjb`に当たります。

また、手順の3番目で`Pia`と`Qjb`が同じコンセプトによる制約になっているとは、そのまま引数型まで含めて同じコンセプトによる制約になっている場合をいいます。ただしここで注意なのは、コンセプトによらない通常の`bool`式による制約（例えば型特性`std::is_same_v<...>`や比較演算`sizeof(T) == 4`など）では通常これが成り立たず、一見同じ制約式でも異なる制約とみなされます。

このことはC++20 コア言語機能においても触れていましたが、特に問題なのはコンセプトの否定（例えばコンセプト`C<T>`に対する`!C<T>`）もこれに該当してしまう事です。`!`によるコンセプトの制約式の否定はそれが1つの個別の制約式かつ非コンセプトの制約式となるため、`Pia`と`Qjb`に意味的に同一となるそのような否定コンセプトのペアがあってもそれは同じ制約にはなりません。標準形への変換のところで言及していた注意点とはこのことで、このためにコンセプトの制約式ではド・モルガンの法則も二重否定の除去も（意味的には）成り立ちません。幸いこれは、コンセプトの否定を1つのコンセプトとして切り出してしまうと解決できます。

```cpp
// コンセプトAとBがあるとして

template<typename T>
  requires !A<T>
void f(); // (1)

template<typename T>
  requires !A<T> && B<T>
void f(); // (2)

template<typename T>
concept notA = !A<T>;

template<typename T>
  requires notA<T>
void g(); // (3)

template<typename T>
  requires notA<T> && B<T>
void g(); // (4)


int main() {
  // TはAを満たさないがBを満たすとする
  f<T>(); // ng、呼び出しが曖昧

  g<T>(); // ok、(4)が呼ばれる
}
```

ただし、意味的には成り立たなくても変形は適用可能なので、C++コンパイラは制約式の標準形への変換に際して容赦なくそれを行うでしょう。コンセプトの順序が重要になる場合は、否定（`!`）の扱いには注意する必要があります。

さて、一通り説明を終えたところで最初の例に戻りましょう。

```cpp
template<typename T>
  requires ((A<T> && B<T>) || C<T>) && D<T>
void f(); // (1)

template<typename T>
  requires A<T> || D<T>
void f(); // (2)
```

このオーバーロードの優先順位の判定は、`((A<T> && B<T>) || C<T>) && D<T>`と`A<T> || D<T>`の間で順序が付くかどうか（どちらがより制約されているのか）を先程の手順によって判定すればわかります。

まずは`((A<T> && B<T>) || C<T>) && D<T>`を選言標準形に変換します

```
  ((A<T> && B<T>) || C<T>) && D<T>
= (((A<T> && B<T>) && D<T>) || (C<T> && D<T>))
= (A<T> && B<T> && D<T>) || (C<T> && D<T>)
```

`A<T> || D<T>`は既に連言標準形になっているのでこのまま使用します。

次に、それぞれの部分式を取り出します。

```
Pi = (A<T> && B<T> && D<T>), (C<T> && D<T>)
Qj = (A<T> || D<T>)
```

そしてこの`Pi`と`Qj`の各項同士をすべて比較して、そのすべてに対して一致する部分式が存在するかを調べます。今回比較すべきペアは2つです

```
(A<T> && B<T> && D<T>) : (A<T> || D<T>)
(C<T> && D<T>) : (A<T> || D<T>)
```

まず1つ目のペアの左辺は、`A<T>, B<T>, D<T>`の3つの部分式からなり、右辺は`A<T>, D<T>`の2つの部分式からなります。どちらにも`A<T>`と`D<T>`が含まれているため、左辺の方が右辺よりもより制約されています。

2つ目のペアはそれぞれ、`C<T>, D<T>`の2つと`A<T>, D<T>`の2つの部分式からなります。どちらにも`D<T>`が含まれているため、こちらも左辺の方が右辺よりも制約されています。

```
(A<T> && B<T> && D<T>) > (A<T> || D<T>)
 ^^^^            ~~~~     ^^^^    ~~~~
(C<T> && D<T>) > (A<T> || D<T>)
         ^^^^             ^^^^
```

比較すべきペア全てにおいて`Pi`の方が`Qj`よりも制約されているため、`((A<T> && B<T>) || C<T>) && D<T>`の方が`A<T> || D<T>`よりも制約されていることが分かりました。

コンセプトの順序付けにおいては双方向でこの制約関係を調べる必要があり、なおかつどちらか一方のみがより制約されている場合にのみ順序を付けることができます。そのため、逆方向も同様に調べます。

まずは標準形への変換です。`A<T> || D<T>`はすでに選言標準形なのでこのままでよく、`((A<T> && B<T>) || C<T>) && D<T>`を連言標準形に変換します。

```
  ((A<T> && B<T>) || C<T>) && D<T>
= ((A<T> || C<T>) && (C<T> || B<T>)) && D<T>
= (A<T> || C<T>) && (C<T> || B<T>) && D<T>
```

次に、それぞれの部分式を取り出します。

```
Pi = (A<T>), (D<T>)
Qj = (A<T> || C<T>), (C<T> || B<T>), (D<T>)
```

そしてこの`Pi`と`Qj`の各項同士をすべて比較して、そのすべてに対して一致する部分式が存在するかを調べます。今回比較すべきペアは6つです

```
(A<T>) : (A<T> || C<T>)
(A<T>) : (C<T> || B<T>)
(A<T>) : (D<T>)
(D<T>) : (A<T> || C<T>)
(D<T>) : (C<T> || B<T>)
(D<T>) : (D<T>)
```

あとはそれぞれのペア事に、さらに部分式を取り出して同じものがあるかどうかを調べます。個別にみるのは省略して結果だけを見ると

```
(A<T>) > (A<T> || C<T>)
 ^^^^     ^^^^
(A<T>) ? (C<T> || B<T>)

(A<T>) ? (D<T>)

(D<T>) ? (A<T> || C<T>)

(D<T>) ? (C<T> || B<T>)

(D<T>) > (D<T>)
 ^^^^     ^^^^
```

今度は、`Pi`と`Qj`のペアの中に順序がつかないものが1つ以上含まれているため、`P`は`Q`よりも制約されているとは言えません。

従って、`A<T> || D<T>`は`((A<T> && B<T>) || C<T>) && D<T>`よりも制約されていないことが分かりました。

- `((A<T> && B<T>) || C<T>) && D<T>` > `A<T> || D<T>`
- `A<T> || D<T>` ? `((A<T> && B<T>) || C<T>) && D<T>`

という双方向の順序が得られてかつその順序が一方向に決まっているため、この2つの制約の間には順序付けを行うことができます。

```cpp
template<typename T>
  requires ((A<T> && B<T>) || C<T>) && D<T>
void f(); // (1)

template<typename T>
  requires A<T> || D<T>
void f(); // (2)

int main() {
  // TはA, B, C, D全てのコンセプトを満たすとして
  f<T>(); // (1)が呼ばれる
}
```

この場合、`T`が`D`を満たしていない場合は(2)が呼ばれることになります。また、`A`も`B`も満たさないが`C`と`D`は満たす場合は(1)が呼ばれ、`D`だけを満たす場合には(2)が呼ばれます。

## コンセプト定義の再帰的な展開

前項の説明はコンセプトが与えられていた場合にその表層的な部分だけに注目して説明したものだったので、実は正しくない部分があります。それは、コンセプトの順序を考えるときに、コンセプトの定義の制約式も

これは、最初に制約式を標準形に変換する際に、現れている各種コンセプトを再帰的に展開してから標準形に変換することで行われます。より正しい手順は次のようになります

1. 1つ目のオーバーロードの制約式を原子制約式だけからなるように展開した制約式を`P`、2つ目のオーバーロードの制約式を原子制約式だけからなるように展開した制約式を`Q`とする
    - 制約式に含まれているコンセプトを、その定義によって置換していく
    - ただし、否定（`!`）されているコンセプトは展開せず、それで一つの原子制約式となる
    - `P, Q`にはコンセプトによる制約は直接的には含まれなくなる
2. `P`を選言標準形、`Q`を連言標準形に変換する
    - 選言標準形は、`()`で囲まれた`&&`の制約を`||`で接続した形の制約
    - 連言標準形は、`()`で囲まれた`||`の制約を`&&`で接続した形の制約
3. `P`の選言標準形の各項（部分式）`Pi`と`Q`の連言標準形の各項`Qj`を比較する
    - `Pi`は必ず`&&`だけからなる制約となっている
    - `Qj`は必ず`||`だけからなる制約となっている
4. それぞれの`Pi`と`Qj`の比較においては、さらにそれの各項`Pia`と`Qjb`を比較し、`Pia`と`Qjb`が同じ原子制約式による制約になっている組が1つでもあれば、`Pi`は`Qj`よりも制約されている（`Pi > Qj`）となる
    - コンセプトの展開によって導入されていない原子制約式は、たとえ意味的にも字句的にも同一のものでも異なるものとして扱われる
5. `P`の選言標準形の全ての項`Pi`が`Q`の連言標準形の全ての項`Qj`よりも制約されている場合に、`P`は`Q`よりも制約されている（`P > Q`）となる

これによって、直接使用されているコンセプトだけを見た場合に一見その順序付けができない場合でも、定義のレベルで順序付けが可能であるならば先程の手順によって順序付けがなされます。

```cpp
template<typename T>
  requires std::integral<T>
void f(); // (1)

template<typename T>
  requires std::signed_integral<T>
void f(); // (2)

int main() {
  f<int>(); // (2)が呼ばれる
}
```

`std::signed_integral`コンセプトは、`std::integral`かつ`std::is_signed_v`によって制約されており、`std::signed_integral`は`std::integral`よりも制約されるように定義されています。

厄介な点の1つ目は、`!C<T>`のように否定されて現れているコンセプトはそれ以上展開されず、これで1つの原子制約式として扱われる点です。これが異なるコンセプト定義から来ている場合、手順4のマッチング時に同じ制約だとはみなされません。

厄介な点の2つ目は、コンセプトを通さず直接現れている非コンセプトの原子制約式とは異なり、コンセプトの定義を展開した結果として現れる非コンセプトの原子制約式は、手順4のマッチング時に、同じコンセプトから来ているものは同じ原子制約式であるとみなされます。これによって、`!`を直接使用せずにコンセプトに分離すれば順序付けが可能となるわけです。

```cpp
template<typename T>
concept A = false;

template<typename T>
concept B = !A<T>;

template<typename T>
concept C = true;

template<typename T>
concept D = !A<T> && C<T>;

template<typename T>
  requires B<T>
void f(); // (1)

template<typename T>
  requires D<T>
void f(); // (2)

template<typename T>
concept E = B<T> && C<T>;

template<typename T>
  requires B<T>
void g(); // (3)

template<typename T>
  requires E<T>
void g(); // (4)

int main() {
  f<int>(); // ng、呼び出しが曖昧
  g<int>(); // ok、(4)が呼ばれる
}
```

この例では、`f<T>`の呼び出しにおいてコンセプト`B<T>`と`D<T>`の比較が行われ、展開し標準形に変換すると`!false_(B)`と`!false_(D) && true_(C)`となります。`B<T>` > `D<T>`の判定をする場合、`Pi = !false_(B)`と`Qi = !false_(D), true_(C)`となりそれぞれの部分式（この場合1つだけ）同士の比較をこなうわけですが、`true_(C)`に対応するものが無いので順序は定まりません。逆向き`D<T>` > `B<T>`の判定をする場合、`Pi = !false_(D) && true_(C)`と`Qi = !false_(B)`となりマッチングを行うわけですが、このとき`!false`という原子制約式だけを見るとマッチングが取れますがその由来までみると`!false_(D)`と`!false_(B)`で出所が異なるため同じ制約とはみなされず、結局`D<T>` > `B<T>`方向も順序が付かずコンパイルエラーとなります。

`g<T>`の呼び出しの場合、`B<T>`と`E<T>`の比較を行うわけですが、`B<T> > E<T>`は先程と同様に順序が付きません。逆向き`E<T>` > `B<T>`の判定をする場合、`Pi = !false_(B) && true_(C)`と`Qi = !false_(B)`となりマッチングを行うわけですが、今度は`E`の`Pi`の部分式`!false_(B)`が`B`の`Qi`の部分式`!false_(B)`とマッチするため、`E<T>` > `B<T>`の順序が付きます。

このように、手作業で判定を行おうとする場合は原子制約式の由来による区別に気を付けなければなりません。なお、コンセプトに包まれていない原子制約式は由来を持たず、その場合は字句的意味的にも同じでも常に異なる制約とみなされます（何度も言っていることですが・・・）。

TODO: 展開したうえで順序付けを求める例をもう一つ追加する。例えば前項で計算してた例など。

# `<=>`演算子における他比較演算子の合成について

`<=>`演算子をデフォルト定義することによって、残りの比較演算子が自動で実装されるようになり、C++20からは比較演算子の実装が著しく簡単になります。しかし、そのためには基底クラス及びメンバ型のすべてが`<=> ==`を定義している必要があります。`==`はともかく、`<=>`はC++20で追加された新しい演算子であり、C++17以前で定義されたクラス型で備えているものはありません。そのため、C++17以前のクラスに対して`<=>`演算子を追加しない場合、`<=>`演算子のデフォルト実装は利用できないことになります。

```cpp
// C++17以前から使用されてきた型、従来の比較演算子は実装されている
struct old_type {
  int n = 10;

  // 共に実装は省略
  bool operator< (const old_type&) const;
  bool operator==(const old_type&) const;
};


// C++20環境で定義された新しい型
struct new_type {
  int m = 10;
  old_type l = {20}; // <=>を持たない
  int n = 30;

  // old_typeは<=>を持たないため、実装不可、暗黙delete
  auto operator<=>(const new_type&) const = default;

  // ==があるため実装可能（明示的な宣言は実は不要）
  bool operator== (const new_type&) const = default;
};

int main() {
  new_type n1{}, n2 = {20, {30}, 40};

  auto comp = n1 <=> n2;  // ng
  bool eq   = n1 == n2;   // ok
}
```

このような例は珍しいものではなく、既存のコードベースをC++20環境へ移行した後に良く遭遇する光景となるでしょう。また、この`old_type`のような型が変更できない場所（外部ライブラリや他人の管轄コードベースなど）に存在していると`<=>`を追加することもできません。

このような場合でも`<=>`演算子をなるべく書かなくて済むようにするために、`< ==`の2つの演算子を使用して`<=>`を自動実装する仕組みが用意されています。

```cpp
struct new_type {
  int m = 10;
  old_type l = {20};  // <=>を備えていない
  int n = 30;

  // 指定した戻り値型とold_typeの持つ比較演算子を用いて実装してもらう
  std::strong_ordering operator<=>(const new_type&) const = default;
};

int main() {
  new_type n1{}, n2 = {20, {30}, 40};

  auto comp = n1 <=> n2;  // ok
  bool eq   = n1 == n2;   // ok
}
```

このように、戻り値の比較カテゴリ型を明示的に指定したうえで`default`指定することで、`<=>`演算子が利用可能ではない型がある場合は`< ==`を用いて比較を実装するようになります。

この場合の`default`実装を明示的に書くと次のようになります

```cpp
struct new_type {
  int m = 10;
  old_type l = {20};
  int n = 30;

  //std::strong_ordering operator<=>(const new_type&) const = default;
  std::strong_ordering operator<=>(const new_type&) const = default {
    // <=>が使える場合はそれを使用
    if (auto comp = static_cast<std::strong_ordering>(m <=> that.m); comp != 0) return comp;

    // <=>が使えない場合は< ==から比較を実装
    std::strong_ordering comp = (l == that.l) ? std::strong_ordering::equal :　
                                (l <  that.l) ? std::strong_ordering::less
                                              : std::strong_ordering::greater;
    if (comp != 0) return comp;

    return static_cast<std::strong_ordering>(n <=> that.n);
  }
};
```

比較しようとするメンバ（基底クラスサブオブジェクト）を`a, b`、指定された戻り値型を`R`としたときに、このように戻り値型を明示的に指定する場合の比較の実装は`R`によって次のようになります

```cpp
// a <=> bが使用可能な場合
static_cast<R>(a <=> b);

// Rがstd::strong_orderingであり
// a < b, a == bが共に使用可能な場合
a == b ? std::strong_ordering::equal : 
a < b  ? std::strong_ordering::less
       : std::strong_ordering::greater;

// Rがstd::weak_orderingであり
// a < b, a == bが共に使用可能な場合
a == b ? std::weak_ordering::equivalent :
a < b  ? std::weak_ordering::less :
       : std::weak_ordering::greater;

// Rがstd::partial_orderingであり
// a < b, a == bが共に使用可能な場合
a == b ? std::partial_ordering::equivalent : 
a < b  ? std::partial_ordering::less : 
b < a  ? std::partial_ordering::greater
       : std::partial_ordering::unordered;
```

実装内では、この結果（必ず比較カテゴリ型のいずれかになる）を受け取って、それが`0`と等しくなければそれを返して終了、`0`と等しければ次へ、のような実装を行います（この部分は戻り値型を`auto`にする場合と同じ）。

このように戻り値型の指定を明示的に行った場合にのみ`< ==`を使用した実装を行っているのは、`partial_ordering`の`unordered`の判定および`weak_ordering`の`equivalent`を正しくハンドルするためです。戻り値型を指定しない場合、これらの値は全て`strong_ordering::equal`として扱われてしまうため、適切な比較にならない可能性があります。

## クラステンプレートにおける適応的な比較演算子自動生成

より汎用的というなら、戻り値型を常に指定して`<=>`を`default`実装する方がより広い状況で`<=>`を実装することができます。ただし、戻り値型を明示的に指定してしまうと、各メンバ・基底クラスの比較がその戻り値型に明示的に変換可能ではない場合にエラーになってしまいます。また、`auto`で本来導出される比較カテゴリ型とは異なる最適ではないカテゴリになってしまう可能性もあります。

```cpp
template<typename T>
struct wrap {
  T v;

  // Tの<=>の結果がweak_orderingに変換できない場合にエラーになる
  std::weak_ordering operator<=>(const wrap&) const = default;
};

int main() {
  wrap<double> w1{0.0}, w2{1.0}; // ok。ここではエラーにならない

  bool cmp = w1 < w2; // ng、<=>はdeleteされている
}
```

`double`の`<=>`の比較結果は`std::partial_ordering`であり、`std::weak_ordering`は`std::partial_ordering`に変換できないため比較演算子を使用しようとするとエラーになります。

つまり、`<=>`が使用できる場合は戻り値`auto`の宣言を、使用できない場合は戻り値型を指定した宣言を使ってほしいのですが、そのようなことはできません。

```cpp
template<typename T>
struct wrap {
  T v;

  // この2つの宣言を同居できない
  auto operator<=>(const wrap&) const = default;
  std::weak_ordering operator<=>(const wrap&) const = default;
};
```

この`wrap<T>`のように、メンバとして持つ型がテンプレートパラメータによって指定されているような場合、この問題は悩ましいものになるでしょう。

このような場合のために、`<compare>`に用意されている機能を使用して1つの宣言でこの要求を叶えるソリューションを考えることができます。

```cpp
// Tが<=>を使用できない場合、Catにフォールバックする
template<typename T, typename Cat>
using fallback_comp3way_t = std::conditional_t<
        std::three_way_comparable<T>,
          std::compare_three_way_result<T>,
          std::type_identity<Cat>
      >::type;
```

`std::three_way_comparable<T>`は`T`が`<=>`によって比較可能であることを定義するコンセプトです、それによって`<=>`の利用可否を判定して、利用できる場合は`std::compare_three_way_result<T>`によってその結果型を取得して返し、できない場合はフォールバック先の比較カテゴリ型`Cat`を返します。

結局、`fallback_comp3way_t<T, Cat>`は、`T`が`<=>`を利用可能であればその結果型、利用できなければ`Cat`になります。

これを使って先程の`wrap`を書き換えると

```cpp
template<typename T>
struct wrap {
  T t;

  // <=>を使用可能ならそれを、そうでないなら< ==を使ってdefault実装
  auto operator<=>(const wrap&) const
    -> fallback_comp3way_t<T, std::weak_ordering>
      = default;
};

// <=>は定義していないが、< ==は定義してあるクラス
struct no_spaceship {
  int n;

  bool operator<(const no_spaceship& that) const noexcept {
    return n < that.n;
  }

  bool operator==(const no_spaceship& that) const noexcept {
    return n == that.n;
  }
};

int main() {
  { 
    wrap<double> w1{0.0}, w2{1.0};

    // 全て利用可能
    bool b1 = w1 < w2;  // true
    bool b2 = w1 <= w2; // true
    bool b3 = w1 > w2;  // false
    bool b4 = w1 >= w2; // false
  }
  { 
    wrap<no_spaceship> w1{0}, w2{1};

    // 全て利用可能
    bool b1 = w1 < w2;  // true
    bool b2 = w1 <= w2; // true
    bool b3 = w1 > w2;  // false
    bool b4 = w1 >= w2; // false
  }
}
```

厳密には`auto`のままで定義しているわけではありませんが、`<=>`が利用できる場合の結果型は`auto`で宣言した場合と同じ結果になり、なおかつ利用できない場合でも指定した比較カテゴリ型にフォールバックすることでなるべく自動実装してもらうことができます。

対象となるテンプレートパラメータが複数ある場合は`std::common_comparison_category_t`を組み合わせて使用することでこのソリューションを引き続き使用することができます。

```cpp
// フォールバック先のカテゴリ
using category = std::weak_ordering;

template<typename T1, typename T2, typename T3>
struct triple {
  T1 t1;
  T2 t2;
  T3 t3;

  // <=>を使用可能ならそれを、そうでないなら< ==を使ってdefault実装
  auto operator<=>(const triple&) const
    -> std::common_comparison_category_t<
          fallback_comp3way_t<T1, category>,
          fallback_comp3way_t<T2, category>,
          fallback_comp3way_t<T3, category>
        >
      = default;
};

int main() {
  triple<int, double, no_spaceship> t1 = {10, 3.14, {20}}, 
                                    t2 = {10, 3.14, {30}};

  // 全て利用可能        
  bool b1 = t1 < t2;  // true
  bool b2 = t1 <= t2; // true
  bool b3 = t1 > t2;  // false
  bool b4 = t1 >= t2; // false
}
```

実はこの`fallback_comp3way_t`はライブラリ機能1でも紹介していました。しかし、そこでは戻り値型を指定した`<=>`の`default`宣言をほとんど説明していなかったため、その説明と合わせて改めて解説を行いました。

これをさらに発展させて`<`だけから`<=> ==`を定義する、みたいなことも考えることもできます（さらに複雑にはなりますが・・・）。

# `<chrono>`のスキップしたもの

## `hhmmss`

## タイムゾーンデータベース

# `consteval`コンストラクタによるコンパイル時検査について

# 謝辞

本書を執筆するに当たっては以下のサイトをとても参照しました。サイト管理者及び編集者・執筆者の方々に厚く御礼申し上げます。

- cpprefjp(https://cpprefjp.github.io/ : ライセンスはCC-BY 3.0)
- cppreference(https://ja.cppreference.com/w/cpp : ライセンスはCC-BY-SA 3.0)
- Compiler Explorer(https://godbolt.org/)
- 制約とコンセプトとオーバーロードと半順序(https://qiita.com/kazatsuyu/items/ea6b8f1c8c7d384505b8)
- IV. 命題論理の意味論（その２）(https://www2.yukawa.kyoto-u.ac.jp/~kanehisa.takasaki/edu/logic/logic4.html)

また、大阪C++読書会において以前に発行したC++20コア言語機能及びC++20ライブラリ機能1を輪読していただき、感想等のフィードバックを頂いております。モチベーションになっています、ありがとうございます！

- [大阪C++読書会 - connpass](https://cpp-osaka.connpass.com/ )
- [大阪C++読書会 - scrapbox](https://scrapbox.io/cpp-osaka/ )
