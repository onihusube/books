---
title: C++ return文で起こること
author: onihusube
date: 2023/08/12
geometry:
  width: 188mm
  height: 263mm
#coverimage: cover.jpg
#backcoverimage: backcover.jpg
titlecolor:
  color1:
    r: 0.7882
    g: 0.6745
    b: 0.9092
    c: 0.25
    m: 0.3
    y: 0.0
    k: 0.0
  color2:
    r: 0.6
    g: 0.0
    b: 0.6
    c: 0.3
    m: 0.95
    y: 0.0
    k: 0.0
okuduke:
  revision: 初版
  printing: ねこのしっぽ
---
\clearpage

# はじめに

本書はC++20を基にして記述されています。そのため、C++20までに導入されている機能については特に導入バージョンについて触れません。ただし、一部C++23に関する部分があり、それについてはC++23で変更・追加された機能であることを明示します。

## サンプルコードのお約束

- ヘッダのインクルードは全て省略し、サンプルコードの最初で`import std;`しているものとします。
- 主題と関係ないところを`...`で省略していることがあります。
- 行の末尾コメントで`ok/ng`と表示することで、それがコンパイル可能かどうかを示しています。`// ok`はコンパイルが通り未定義動作がないこと、`// ng`はコンパイルエラーとなる事をそれぞれ表しています。

コードブロック中で標準出力をしている時、直後のブロックでその出力例を示していることがあります。例えば次のようになっています

```cpp
int main() {
  std::cout "hello world!";
}
```
```{style=planetext}
hello world!
```

\clearpage

# `return`文の基礎

ここでは、`return`文の基本事項をまとめておきます。そんなん知っとるわ！という方は読み飛ばしても構いません。

## 文法

C++の文法定義中では、`return`は`statement`の内の`jump-statement`の一種として定義されています

```
statement:
  labeled-statement
  attribute-specifier-seq(opt) expression-statement
  attribute-specifier-seq(opt) compound-statement
  attribute-specifier-seq(opt) selection-statement
  attribute-specifier-seq(opt) iteration-statement
  attribute-specifier-seq(opt) jump-statement
  declaration-statement
  attribute-specifier-seq(opt) try-block

jump-statement:
  break ;
  continue ;
  return expr-or-braced-init-list(opt);
  coroutine-return-statement
  goto identifier ;
```

これはC++の規格にある文法定義のEBNFを少し改変（下付き文字の`opt`を`(opt)`に変更）したものです。

`statement`とは文の定義を指しており、`return`は文（*statement*）であり式（*expression*）ではありません。

`statement`中の`jump-statement`参照箇所の定義より、属性指定を`return`文に行う場合は`return`の前で行います（現在のところ標準の属性にはそのような属性は存在しませんが）。

```cpp
auto f() {
  // returnに対する属性指定
  [[attribute]] return ...;

  // こうでも良い
  [[attribute]]
  return ...;
}
```

この`jump-statement`が直接参照される規則はなく、常に`statement`を介して参照されます。`statement`は直接参照されるか`compound-statement`を介して参照されます

```
compound-statement:
  { statement-seq(opt) label-seq(opt) }

statement-seq:
  statement
  statement-seq statement
```

`statement-seq`とは`statement`の列で、`compound-statement`とはいわゆるブロック（`{}`）構造のことを指しています。

この`compound-statement`及び`statement`は他の文や構文などから参照されます。

```
// if/switch
selection-statement:
  if constexpr(opt) ( init-statement(opt) condition ) statement
  if constexpr(opt) ( init-statement(opt) condition ) statement else statement
  if !(opt) consteval compound-statement
  if !(opt) consteval compound-statement else statement
  switch ( init-statement(opt) condition ) statement

// for/while
iteration-statement:
  while ( condition ) statement
  do statement while ( expression ) ;
  for ( init-statement condition(opt) ; expression(opt) ) statement
  for ( init-statement(opt) for-range-declaration : for-range-initializer ) statement

// ラムダ式
lambda-expression:
  lambda-introducer attribute-specifier-seq(opt) lambda-declarator compound-statement
  lambda-introducer < template-parameter-list > requires-clause(opt) attribute-specifier-seq(opt) lambda-declarator compound-statement

// 関数宣言
function-body:
  ctor-initializer(opt) compound-statement
  function-try-block
  = default ;
  = delete ;

// try-catch
try-block:
  try compound-statement handler-seq
function-try-block:
  try ctor-initializer(opt) compound-statement handler-seq
handler-seq:
  handler handler-seq(opt)
handler:
  catch ( exception-declaration ) compound-statement
```

これらの構文中の、`compound-statement`及び`statement`の場所に`return`文を書くことができるわけです。C++23時点ではその場所はこれが全てのはずです。

長々と文法を示してきましたがここで驚くべきことは特にありません。`return`文は皆さんが通常書けると思っているところに書くことができ、書けないと思っているであろう場所には書くことができません。

## `return`の構文と効果

`return`文の文法定義（`return expr-or-braced-init-list(opt);`）を少し解いてみると、その構文は次のいずれかの形になります

```
return;
return expr;
return {...};
```

一番上の形式は戻り値型が`void`の関数における`return`文の書き方で、残りは何かしら戻り値を返す場合の`return`文の書き方です。

`return`文の効果は、実行がそこに到達すると現在呼び出し中の関数を終了して呼び出し元に戻る、というものです。その際、式あるいは初期化子（`return`文のオペランド式）が指定されている場合（下2つの形式）は、そのオペランド式から戻り値型のオブジェクトを構築して呼び出し元に返します。

関数の実行が`return`文に到達すると、次の順序で関数の終了処理が行われます

1. `return`文のオペランド式の実行
    - `return`文のオペランド式の実行によって一時オブジェクトが生成される場合、その解法は戻り値初期化の後かつローカル変数解放の前
2. 戻り値の初期化
3. ローカル変数の解放（デストラクタ実行とスタック解放）
    - 宣言と逆順で解放する
4. 関数引数の解放
    - 解放の順序は呼び出し規約によって異なる
    - 呼び出し規約によっては、関数引数の解放は呼び出し元が行う（関数の終了後に行われる）
5. 関数の終了（呼び出し元への復帰）

### 暗黙に`return`されるところ

次の場所では、明示的な`return`文なしに関数が正常に`return`します

1. 戻り値型が`void`な関数の本体（関数`try`ブロックを含む）終端
2. コンストラクタ/デストラクタの終端
3. `main()`の終端

1と2の場合は`return;`が暗黙に実行されたかのように扱われ、3の場合は`return 0;`が暗黙に実行されたかのように扱われます。

```cpp
void f() {
  int n = 10;
  std::cout << n;
  //return;
}

struct S {
  int n;

  S(int m) : n{m} {
    std::cout << n;
    //return;
  }

  ~S() {
    std::cout << n;
    //return;
  }
}

int main() {
  f();
  //return 0;
}
```

これ以外の場所で`return`文を省略すると未定義動作となります。

```cpp
int f() {
  int n = 10;
  std::cout << n;

  // UB!
}

int g(bool b) {
  if (b) {
    return 20;
  }

  // UB!
}
```

これはコンパイルエラーではなく未定義動作となります。コンパイラはおそらく警告してくれますがエラーにはしてくれないため、そのようなパスが実行されると意図しない結果をもたらします（おそらく実行時にストップせず通過し、戻り値の利用が安全ではなくなります）。

これがエラーにならないのは、例外を投げるなどをした場合に到達し得ないパスがあり得るためです。

```cpp
int g(bool b) {
  if (b) {
    return 20;
  }

  throw std::runtime_error{"b = false!"};
  // ここには絶対に到達しない
}
```

コンパイラによっては、この場合に`return`文がないという警告が抑制される場合があります。

### `[[noreturn]]`属性

先ほどの例のように到達しないことがわかっている場合に`return`文を省略した時でも、コンパイラによっては`return`文がないという警告が表示される場合があります。そのような場合に警告抑制を確実にするためには、`[[noreturn]]`属性を付加した関数で実質最後の実行パス（先ほどの例なら`throw`）をラップします。

```cpp
[[noreturn]]
void err() {
  throw std::runtime_error{"b = false!"};
}

int g(bool b) {
  if (b) {
    return 20;
  }

  err();
  // ここには絶対に到達しない
  // return文がないという警告は抑制される
}
```

`[[noreturn]]`属性はその関数呼び出しが正常に`return`しないことを表明する関数に対する属性指定です。なお、`[[noreturn]]`属性が指定された関数が正常に`return`してしまうと、それはそれで未定義動作になります。

```cpp
[[noreturn]]
void err(bool b) {
  if (b) {
    throw std::runtime_error{"b = false!"};
  }

  // UB!
}
```

## 戻り値型推論

関数の戻り値型にはプレースホルダ型指定（`auto`や`decltype(auto)`など）を置くことができて、この場合は戻り値型が関数の`return`文から推論されます。

```cpp
// 戻り値型推論を行う関数宣言のバリエーション
auto f();
decltype(auto) f();
auto& f();
auto&& f();
auto* f();
```

これらに加えて、`auto`+`const/volatile`修飾（ただし参照/ポインタ修飾がない場合は無意味）及び後置戻り値型（後置と前置で意味は変わらない）においても同様のプレースホルダ型指定の使い方によって戻り値型推論が可能です。以降は、参照以外に対するCV修飾及び後置戻り値型に関しては考慮せずにこれらのバリエーションについて見ていきます。複雑なことですが、これらのバリエーションでは最終的に推論される型が異なることがあります。

戻り値型としてプレースホルダ型指定がなされた関数においては、その戻り値型はその関数本体の`return`文のオペランド（戻り値式）の型から推論されます。もし関数に`return`文がない場合、戻り値型は`return;`から推論されます。

そして、この推論はプレースホルダ型指定を`auto`として`return`文を`return expr;`とすると、次のような変数`r`の初期化時に推論される型と同じ型になります。

```cpp
auto r = expr;
```

プレースホルダ型指定の異なるバリエーションでは、この例の`auto`を置き換えたものと同じになります。

そしてこの時の推論は、左辺の初期化式（`return`文のオペランド）`expr`の型から推論されます。ただし、`auto`と`decltype(auto)`では少し異なる推論がなされます。

なお、関数テンプレートにおける戻り値型推論は、`return`文がテンプレートパラメータに依存していなかったとしてもその関数テンプレートがインスタンス化されるときに推論が行われます（つまり、two-phase name lookupの1回目の時には戻り値型は推論されません）。

### `decltype(auto)`の場合

プレースホルダ型指定が`decltype(auto)`の場合は割と単純で、`return`文のオペランドの式である`expr`を`decltype`に渡して得られる型がそのまま戻り値型になります。

```cpp
decltype(auto) f() {
  ...

  // このreturn文からの戻り値型推論は
  return expr;
}

// このような変数宣言におけるrの型として取得され
decltype(auto) r = expr;

// それは次のようなRとなる
using R = decltype(expr);
```

この`R`のような`decltype`の結果は式`expr`の種類によって2つに場合分けされます

- `expr`が変数名を指定する式（つまり変数名だけ）、もしくはメンバ名を指定する式の場合
    - その変数の型を取得する
- `expr`がそれ以外の式の場合
    - 式（`expr`）の型と値カテゴリを取得する

式`expr`の型とはその式を最後まで実行したときに得られる結果の型であり、これは式によりますが多くの場合は推測可能だと思います。式の値カテゴリは、式の結果の値が左辺値となるか右辺値となるかを参照修飾`&`と`&&`で区別します。

式の型を`T`（参照修飾を含まない）とすると式の値カテゴリによって最終的な型は次のようになります

- *lvalue*
    - `T&`
- *xvalue*
    - `T&&`
- *prvalue*
    - `T`

式の値カテゴリがどれになるかは式によりますが、式の種類によって細かく規定されているので少し複雑です。多くの場合、即値ではなく一時オブジェクトを生成しないような式（代入演算子や左辺値オブジェクト経由のメンバアクセス、左辺値参照型戻り値の関数呼び出しなど）の場合はほぼ左辺値（*lvalue*）になります。即値（リテラル、一時オブジェクト）や非参照型を返す式（二項演算子や非参照戻り値型の関数呼び出し）、組み込みの値を生成する式（アドレス取得やラムダ式、`this`など）の場合は*prvalue*というカテゴリになり、*xvalue*となるのは明示的に`std::move`のようなキャストをしているかそのようなものを返す式（右辺値参照戻り値型の関数呼び出しや*xvalue*オブジェクト経由のメンバアクセスなど）の場合くらいのはずです。

```cpp
int n = 0;

decltype(auto) r1 = 0;
// 型はint、式の値カテゴリはprvalue(修飾なし)

decltype(auto) r2 = n;
// 型はint、変数名を指定する式

decltype(auto) r3 = (n);
// 型はint&、式の値カテゴリはlvalue(&)

decltype(auto) r4 = std::move(n);
// 型はint&&、式の値カテゴリはxvalue(&&)
```

これは関数宣言と`return`文に直すと次のようになります

```cpp
int n = 0;

decltype(auto) f1() {
  return 0;
}
// 戻り値型はint

decltype(auto) f2() {
  return n;
}
// 戻り値型はint

decltype(auto) f3() {
  return (n);
}
// 戻り値型はint&

decltype(auto) f4() {
  return std::move(n);
}
// 戻り値型はint&&
```

`decltype(n)`のオペランドは変数名を指定する式ですが、`decltype((n))`のオペランドはかっこに囲まれた式であり、前者は変数の型を取得し、後者は式の型と値カテゴリを取得します。これによって、結果に左辺値参照修飾が含まれるかどうかが違ってきます。

とても単純な見方としては、`decltype(auto)`による戻り値型推論は`return`文のオペランドを`decltype(auto)`の`auto`に突っ込んで推論される、と見ることができます。

```cpp
decltype(auto) f() { return expr; }
//        ^                 ~~~~
//        |__________________|
```

なお、プレースホルダ型指定に`decltype(auto)`を使用する場合は`const`や参照修飾などを付加することはできず、ちょうど`decltype(auto)`だけが使用可能です。

```cpp
decltype(auto) & ng();        // ng
const decltype(auto) ng();    // ng
const decltype(auto) & ng();  // ng
```

### `auto`（+修飾）の場合

`auto`の場合は仕組み的には関数テンプレートの実引数推論と同じ推論が行われます。そこでは、戻り値型指定内の`auto`をテンプレートパラメータ`T`に置換した形の引数を持つ1引数関数テンプレートを作成し、その仮の関数テンプレートに`return`文のオペランド（`expr`）を渡した時に`T`に推論される型が戻り値型となります。

```cpp
auto f() {
  ...

  // このreturn文からの戻り値型推論は
  return expr;
}

// このような変数宣言におけるrの型として取得され
auto r = expr;

// それはこのような仮の関数テンプレートに対して
template<typename T>
void hf(T r);

// こう渡したときのTが推論結果となる
hf(expr);
```

このとき修飾が付いている場合（`auto&, auto*`など）、修飾はそのままに`auto`だけをテンプレートパラメータに置換した関数テンプレートを考えます

```cpp
// const auto&の場合の仮の関数テンプレート
const auto& f();

template<typename T>
void hf(const T&);


// auto*の場合の仮の関数テンプレート
auto* f();

template<typename T>
void hf(T*);
```

実際にこのような関数テンプレートで推論される型というのは非常に複雑なルールで決まります。その詳細はあまりに複雑なので（書いてる人も雰囲気でしかわかってないので）踏み込まず、`return`文のオペランド（`expr`）の型（値カテゴリを含む）と戻り値型のプレースホルダ指定の組み合わせ毎に戻り値型がどうなるのかをまとめておきます

|`expr`の型|`auto`|`auto&`|`const auto&`|`auto&&`|`auto*`|
|---|---|---|---|---|---|
|`T`|`T`|×|`const T&`|`T&&`|×|
|`T&`|`T`|`T&`|`const T&`|`T&`|×|
|`T&&`|`T`|×|`const T&`|`T&&`|×|
|`const T`|`T`|×|`const T&`|`T&&`|×|
|`const T&`|`T`|`const T&`|`const T&`|`const T&`|×|
|`const T&&`|`T`|`const T&`|`const T&`|`const T&&`|×|
|`T*`|`T*`|×|`T const *&`|`T*&&`|`T*`|
|`T const *`|`T const *`|×|`T const * const &`|`T const *&&`|`T const *`|
|`T * const`|`T*`|×|`T const *&`|`T*&&`|`T*`|
|`T const * const`|`T const *`|×|`T const * const &`|`T const *&&`|`T const *`|
|`T(&)[N]`|`T*`|`T(&)[N]`|`const T(&)[N]`|`T(&)[N]`|`T*`|
|`R(*)(Args)`|`R(*)(Args)`|×|`R(* const &)(Args)`|`R(*&)(Args)`|`R(*)(Args)`|
|`R(&)(Args)`|`R(*)(Args)`|`R(&)(Args)`|`R(const &)(Args)`|`R(&)(Args)`|`R(*)(Args)`|

表中の×は推論不可、すなわち戻り値型が定まらないためコンパルエラーとなる組み合わせです。`T`には任意の型をはめてください。`Args`は関数引数型を表すパラメータパックだと思ってください。

プレースホルダ型指定の`const auto&&`はおそらく使う機会がないと思われるため省略しています。それを考えるときは、`auto&&`の結果にトップレベルの`const`を付加したものと同じになるはずです。

例えば、プレースホルダ指定が`auto`で`return`文が`return 10;`（`10`の型は参照なしの`int`）の場合は戻り値型は`int`と推論され、プレースホルダ指定が`auto&&`になると戻り値型は`int&&`と推論され、プレースホルダ指定を`auto&`にするとコンパイルエラーとなります。

```cpp
auto f1() {
  return 10;
}
// 戻り値型はint

auto&& f2() {
  return 10;
}
// 戻り値型はint&&

auto& f3() {
  return 10;
}
// これはエラー
```

式の型に関しては式毎に処理を追って確かめるか、`decltype((expr))`で取得することもできます。ただし前述のように、変数名を指定する`decltype()`は式の型を取得しないので、変数名であるかに関わらず式の型を取得したい場合はオペランドを`()`で囲っておく必要があります。ただ、変数名を指定する式の型はその変数の型`T`に対して`T&`になるので、そこまで難しくはないでしょう。

```cpp
int n = 10;

auto f1() {
  return n;
}
// 戻り値型はint

auto&& f2() {
  return n;
}
// 戻り値型はint&

auto& f3() {
  return n;
}
// 戻り値型はint&
```

### `void`に推論されるとき

`auto`系にせよ`decltype`にせよ、`return`文にオペランドがない場合はオペランドとして`void()`が使用され、`return`文がない場合は関数の最後で`return;`があるかのように扱われます。つまり結局、どちらの場合も`return void();`のような`return`文として結果を考えることができます。

とはいえ、これはあまり考えることもなく`void`に推論されます。このとき、`auto&`や`auto*`がプレースホルダ指定に使用されている場合はコンパイルエラーとなります。

```cpp
auto f1() {
  return;
}
// 戻り値型はvoid

decltype(auto) f2() {
  return;
}
// 戻り値型はvoid

auto f3() {
}
// 戻り値型はvoid

auto& f4() {
  return;
}
// エラー

auto* f5() {
  return;
}
// エラー、void*にはならない
```

また、`return`文のオペランドの結果型が`void`となる場合も戻り値型は`void`に推論されます。これは別の関数の呼び出し結果を直接`return`しているような場合が該当します。この場合、`return`文から`void`の結果を返そうとしているように見えて、一見するとエラーになりそうに見えますがエラーにはなりません。実のところ、`void`戻り値型の関数の`return`文のオペランドに結果が`void`となる式（多くの場合は関数呼び出し）を書いてもエラーにはなりません。

```cpp
auto f(std::invocable<int> auto func) {
  return func(10);  // この時点では、func()の戻り値型は不明
}

int f1(int n) {
  return 2*n;
}

void f2(int n) {
  std::cout << n << '\n';
}

void f3() {
  return f2(20);  // ok
}

int main() {
  f(f1);  // ok、f()の戻り値型はint
  f(f2);  // ok、f()の戻り値型はvoid
}
```

この挙動によって、この`f()`のように関数テンプレートで呼び出し可能なものを受け取りその呼び出し結果を直接返すもののその結果型がどうなるかわからないような場合でも、`return`文を同じように書くことができる（結果型を調べて分岐する必要がない）ためTMPの文脈で重宝します。

### 初期化子リストからの戻り値型推論

`return`文のオペランドが初期化子リスト（`{...}`）である場合、戻り値型推論は常に失敗します。

```cpp
auto f1() {
  return {1}; // ng、戻り値型が推論できない
}

auto&& f2() {
  return {1, 2};  // ng、戻り値型が推論できない
}

decltype(auto) f3() {
  return {1, 2, 3}; // ng、戻り値型が推論できない
}
```

これは初期化子リストの要素数や`auto`の修飾に関わらず常に失敗します。`initializer_list`には推論されません。

変数宣言の場合、`auto`は初期化子リストから`initializer_list`を推論できますが`decltype(auto)`はできないという違いがあり、戻り値型推論ではこの挙動を`decltype(auto)`に合わせた振る舞いになっています。

```cpp
int main() {
  auto           il1 = {1, 2, 3};  // ok、initializer_list<int>
  decltype(auto) il2 = {1, 2, 3};  // ng
}
```

### `return`文が複数ある場合

戻り値型推論を行う関数に複数の`return`文があるとき、戻り値型は`return`文それぞれに対して個別に推論され、最後に推論された全ての戻り値型が一致している場合にのみその型を戻り値型として採用します。もしも、`return`文の間で推論された戻り値型が異なる場合、推論は失敗します。

```cpp
auto f1(bool b) {
  if (b) {
    return 10;    // ng、推論結果はint
  } else {
    return 10.0;  // ng、推論結果はdouble
  }
}

auto f2(bool b) {
  int n = 10;
  const int& r = n;

  if (b) {
    return n; // ok、推論結果はint
  } else {
    return r; // ok、推論結果はint
  }
}

// 危険なので真似しないこと！
auto& f3(bool b) {
  int n = 10;
  const int& r = n;

  if (b) {
    return n; // ng、推論結果はint&
  } else {
    return r; // ng、推論結果はconst int&
  }
}

// 危険なので真似しないこと！！
decltype(auto) f4(bool b) {
  int n = 10;
  int& r = n;

  if (b) {
    return (n); // ok、推論結果はint&
  } else {
    return r;   // ok、推論結果はint&
  }
}
```

この一致は修飾等も含めて正確に同じ型でなければならず、暗黙変換などは考慮されません。そして、この例の`f2`と`f3`のように`auto`に付加する修飾によって推論結果が一致するかどうかが変化する場合があります。

`f3`や`f4`の例はあくまでどういう推論がなされて一致するかの例を示しているものに過ぎません。このような関数を実際書くことは大変危険なのでやめましょう。

### 例

ここには、いくつかの推論の例を置いておきます。

```cpp
// 配列参照を返す関数
auto test() -> int(&)[10];

auto f1() {
  return test();  // 戻り値型はint*
}

auto& f2() {
  return test();  // 戻り値型はint(&)[10]
}

decltype(auto) f3() {
  return test();  // 戻り値型はint(&)[10]
}
```

```cpp
// 戻り値型が1つに定まらないためエラーとなる例
auto f(int n) {
  if (n < 0) {
    return std::optional{n}; // 推論結果はoptional<int>
  } else {
    return std::nullopt;     // 推論結果はnullopt_t
  }
}
```


```cpp
int main() {
  auto l1 = [](int n) {
    return n; // 戻り値型はint
  };

  auto l2 = [](int n) -> decltype(auto) {
    return (n); // 戻り値型はint&
  };

  auto l3 = [](int n) -> auto&& {
    return (n); // 戻り値型はint&
  };
}
```

ラムダ式の場合、戻り値型としてデフォルトで暗黙的に`auto`指定が使用されています。これを変更するには、後置戻り値型指定で別のプレースホルダ指定を行います。あまり意味はない（と思われる）のですが、普通の関数でも後置戻り値型指定でプレースホルダを指定して戻り値型推論を指示することができます。


## 戻り値の初期化と暗黙変換

`return`文はそこに到達すると関数を終了し呼び出し元に帰ると共に、戻り値型が`void`ではない場合は戻り値の初期化を行います。その際の初期化は`return`文のオペランドからコピー初期化によって行われます。

また、戻り値初期化時には`return`文のオペランドの型と戻り値型が異なる場合に暗黙変換が行われます。これはそれぞれの型の種別に関係なく実行され、関数呼び出し時の引数初期化時や変数の初期化時に起こる暗黙変換と同じものです。この時、暗黙変換の経路が見つからないか、複数見つかる場合はコンパイルエラーとなります。

暗黙変換をするか否か、どの経路で行うかについては戻り値型が決定した後、すなわち戻り値型推論の後で（コンパイル時に）決定されます。戻り値型推論が行われている場合はおそらくあまり大きな変換は行われず、CV修飾や参照修飾の調整、参照からポインタへの変換などに留まるはずです。

関数の戻り値型を`R`とし、`return`文のオペランドを`expr`とすると、戻り値の初期化は単純には次のような変数`r`の初期化と同様です

```cpp
R r = expr;
```

`expr`を関数呼び出しだとするとこれは当たり前に見えるかもしれませんが、この`r`はあくまで戻り値の初期化であってそれを受ける変数の初期化とは異なります。関数呼び出し側で戻り値を受ける変数はこの`r`を用いて再度初期化されることになります。

```cpp
R f() {
  return expr;
}

int main() {
  // このようなvの初期化においては
  auto v = f();

  // この2段階の初期化が行われている（C++意味論的には）
  R r = expr;             // f()の戻り値の初期化
  auto v = std::move(r);  // 変数vの初期化
}
```

以降、この節で説明するのはこの`r`の初期化であって`r`を用いた`v`の初期化ではありません。`v`の初期化は話が少し異なるため一応区別しておきます。ただ、ここには戻り値最適化が関わってくることでその2つは混じり合っており、それによって戻り値の初期化もこの`r`の初期化ほど単純ではなくなっています。戻り値最適化は後半の章の、そして本書のメインテーマです。

`expr`がリスト初期化（`{...}`）の場合はこれはコピーリスト初期化という形の初期化になります。どちらの場合でも`explicit`な変換は禁止され、コピーリスト初期化の場合はさらに縮小変換も禁止されます。

```cpp
auto f1() -> bool {
  std::optional<int> opt = 10;

  return opt; // ng、optionalのbool変換はexplicit
}

auto f2() -> std::shared_ptr<int> {
  int* p = new int{20};

  return p; // ng、shared_ptrの生ポインタコンストラクタはexplicit
}

struct S {
  float f;
};

auto f3(double d) -> S {
  // コピーリスト初期化
  return {d}; // ng、double->floatの縮小変換が起こる
}

auto f4(double d) -> float {
  // コピー初期化
  return d;   // ok、縮小変換は許可される
}
```

縮小変換とはざっくりいうと値の表現が失われるような変換のことで、おおよそ次のいずれかに該当する変換です

- 浮動小数点数型から整数型への変換
- 精度が劣化する浮動小数点数型同士の変換
    - 変換元の値が定数式であり、変換でオーバーフローが発生しない場合は可能
- 整数型から浮動小数点数型への変換
    - 変換元の値が定数式であり、変換でオーバーフローが発生しない場合は可能
- 整数型またはスコープなし列挙型から、元の整数値を全て表現できない整数型への変換
    - 変換元の値が定数式であり、その値が変換先の型で表現可能な場合は可能
- （メンバ）ポインタ型から`bool`型への変換

ただし、コピーリスト初期化における縮小変換は呼ばれるコンストラクタに渡す値が縮小変換を受ける時にだけ禁止されます。コンストラクタでは変換なしで受け取って、コンストラクタ内部で変換を行うようなコンストラクタが呼ばれる場合は禁止されません。

```cpp
struct S {
  int n;
  float f;
};

auto f1(double d) -> S {
  return {d, d}; // ng、集成体初期化において縮小変換が発生する
}

auto f2(double d) -> std::pair<int, float> {
  return {d, d}; // ok、pairのコンストラクタ内部で縮小変換が発生する
}
```

`std::pair`のこの場合呼ばれるコンストラクタは、テンプレート化されてそれぞれの型が対応する要素型に変換できれば選択される（`template<class U, class V> pair(U, V)`のような）もので、コンストラクタ引数では無変換で受け取って、コンストラクタ内で要素を初期化する際に変換するものです。このコンストラクタは条件付き`explicit`指定されているため暗黙変換が禁止されている型では選択されませんが、縮小変換が起こるだけだとリスト初期化時にも選択されます。

コピー初期化はコピーと付いていますがムーブが行われないわけではなく、`expr`が式である場合その値カテゴリによって`R`のコピー/ムーブコンストラクタが適切に選択されます。

```cpp
auto f(int n) -> std::vector<int> {
  if (n == 0) {
    return {1, 2, 3, 4};  // 戻り値はムーブ構築される
  } else {
    std::vector<int> v;
    v.resize(n, 1);

    return v; // 戻り値はコピー構築される
  }
}

int main() {
  auto v1 = f(0);
  auto v2 = f(5);
}
```

ただし、これは後述の暗黙ムーブやコピー省略を考慮しない（あるいは無効化した）場合の挙動になります。実際には暗黙ムーブによって2つ目の`return`文における戻り値はムーブ構築され、コピー省略によって1つ目の`return`文における戻り値は呼び出し側変数（`v1`）に直接構築されます。そして、NRVOが適用されるとどちらの戻り値も呼び出し側変数（`v1, v2`）で直接構築されるようになります。

## `co_return`

（コルーチンの仕様の詳細については、コア言語機能/ライブラリ機能1を参照いただくか、cpprefjpのコルーチンページなどの解説をご覧ください）

`co_return`はコルーチンにおける`return`文であり、文法的には`return`文の一種です。そのため、コルーチン内部である必要がありますが、書ける場所は`return`文と同じになり書き方も同じです。

```
// co_returnの可能な文法
co_return;
co_return expr;
co_return {...};
```

関数に`co_return`文があるとその関数はコルーチンだとみなされますが、コルーチンに普通の`return`文があるとコンパイルエラーになります。

```cpp
auto coro_f() {
  ...

  co_return;  // これによって、この関数はコルーチンとなる

  return; // ng、コルーチンにはreturn文を含められない
}
```

その意味論は`return`文とは異なり、`co_return`文はそこに到達するとその時点で実行中のコルーチンを終了させます。より厳密には、`co_return`文にオペランドがあればそれをプロミス型の`.return_value()`に渡し、なければ`.return_void()`を呼び出して、それらの呼び出しの完了後にコルーチンの最終サスペンドポイントへ移行し、それによってコルーチンを終了させます。

```cpp
auto coro_f() {
  ...

  // これは、exprによって次のどちらかに展開される
  co_return expr;

  // exprがあり、voidの式ではない場合
  {
    promise.return_value(expr);
    goto final_suspend; // コルーチンの最終サスペンドポイントへ移行
  }

  // それ以外（exprが無いか、voidの式）
  {
    {
      expr;
      promise.return_void();
    }
    goto final_suspend; // コルーチンの最終サスペンドポイントへ移行
  }
}
```

`co_return`文は範囲`for`のような言語組み込みマクロのようなもので、コルーチンの明示的終了と終了時処理を実行するためのものですが、その詳細な振る舞いはコルーチンのプロミス型のメンバ関数（`.return_value()/.return_void()`）を通してユーザーが定義します。例えば、コルーチン中で`co_return expr;`としている場合に`expr`の結果の値を`.return_value()`を通してコルーチンの最後の生成結果として返すといったことができます。

なお、`.return_value()/.return_void()`は両方定義するとコンパイルエラーとなり、`.return_void()`が定義されていない状態でコルーチンの終端に到達すると未定義動作となります（`.return_void()`が定義されている場合にのみコルーチン終端到達は`co_return;`と等価となる）。`co_return`のカスタマイズが必要ない場合でも、`.return_void()`は空で定義しておくのが安全です。

\clearpage

# 暗黙ムーブ

## バージョンごとの変化

## C++23 ローカル参照返しの禁止

\clearpage

# コピー省略

一章の「戻り値の初期化と暗黙変換」の節では、戻り値の初期化とそれを受ける変数の初期化を分けて説明していました。

```cpp
R f() {
  return expr;
}

int main() {
  // このようなvの初期化においては
  auto v = f();

  // この2段階の初期化が行われている（C++意味論的には）
  R r = expr;             // f()の戻り値の初期化
  auto v = std::move(r);  // 変数vの初期化
}
```

C++のオブジェクト意味論の要求によって、関数の`return`から呼び出し側での戻り値取得は`expr -> r -> v`のような経路を辿らねばならず、これにはコンストラクタ/デストラクタの呼び出しが伴います。

このような経路は明らかに無駄であり、省けるならば省きたいと思うのはC++という言語としては当然の考えです。そこで、このような場合に`expr -> v`のように経路を圧縮し`return`文のオペランド`expr`によって呼び出し側の変数`v`を直接初期化する最適化を許可しており、このことを値のコピー省略（*Copy Elision*）と呼びます。また、`return`文におけるコピー省略のことを特にReturn Value Optimization(RVO)とも呼びます。本書では単にコピー省略と呼ぶことにします。

## 戻り値の初期化までのコンストラクタ呼び出しの回数

まず、戻り値型を受ける際に実際に上記のような2段階の初期化が行われているのか？あるいは、`return`文から呼び出し元での戻り値を受けている変数の初期化までに何回コンストラクタが呼ばれるのか？を確認してみます。

```cpp
struct log {
  log() {
    std::cout << "default ctor\n";
  }

  log(const log&) {
    std::cout << "copy ctor\n";
  }
};

auto f1() -> log {
  return {}; 
}

auto f2() -> log {
  log c{};
  
  return c; 
}

int main() {
  auto c1 = f1();
  
  std::cout << "-----\n";
  
  auto c2 = f2();
}
```

このようなコードをコピー省略を無効化するオプション（`-fno-elide-constructors`）をつけたgcc12.2で最適化なしでC++11モードでコンパイルし実行すると次のような結果が得られます

```{style=planetext}
default ctor
copy ctor
-----
default ctor
copy ctor
copy ctor
```

少し詳しく見てみると、`c1`の初期化においては`return`文での戻り値構築時にデフォルトコンストラクタが呼ばれ、その戻り値から`c1`を初期化する際にコピーコンストラクタが呼ばれています。`c2`の初期化においては`f2()`ローカルでの`c`の構築時にデフォルトコンストラクタが呼ばれ、`return`文で`c`から戻り値を構築する際にコピーコンストラクタが呼ばれ、その戻り値から`c2`を初期化する際にもう1度コピーコンストラクタが呼ばれています。

```cpp
auto f1() -> log {
  return {}; // 1.1 デフォルトコンストラクタ呼び出し
}

auto f2() -> log {
  log c{}; // 2.1 デフォルトコンストラクタ呼び出し
  
  return c; // 2.2 コピーコンストラクタ呼び出し
}

int main() {
  auto c1 = f1(); // 1.2 コピー（ムーブ）コンストラクタ呼び出し
  
  std::cout << "-----\n";
  
  auto c2 = f2(); // 2.3 コピー（ムーブ）コンストラクタ呼び出し
}
```

まさに、戻り値の構築と戻り値からの呼び出し側変数へのコピー（ムーブ）の2段階の構築が行われていることがわかります。もしこの`log`のような型がコピーが重い型だったら、これによるオーバーヘッドはかなりの重みを持つでしょう。

そして、コピー省略を無効化するオプションを外すと少なくとも`c1`の初期化においてはデフォルトコンストラクタが1回だけ呼ばれるようになり、おそらくほとんどのコンパイラで`c2`の初期化もデフォルトコンストラクタ一回になります。

## `return`文におけるコピー省略

まず大前提としてコピー省略はクラス型においてのみ行われます。組み込み型の場合はコンストラクタ等がトリビアルであるとみなされるため、自然に省略されています。そのため、以降コピー省略の文脈での型といえば何かしらクラス型だと思ってください。

コピー省略は、`return`文のオペランドの値カテゴリが*prvalue*であり、その関数の戻り値型が参照ではない（こちらも*prvalue*という）場合に行われます。式や型が*prvalue*であるとは、その型が参照ではない（その型に参照修飾がない）ことを言い、関数の戻り値型の場合はその関数の呼び出し式の値カテゴリが*prvalue*であることと同じです。

```cpp
struct S { ... };

auto f1() -> S;    // prvalue戻り値（型）
auto f2() -> S&;   // lvalue戻り値（型）
auto f3() -> S&&;  // xvalue戻り値（型）
auto f4() -> S*;   // prvalue戻り値（型）
```

この場合、関数の実装によってコピー省略される可能性があるのは`f1()`だけです。

`return`文のオペランドが*prvalue*であるのは、戻り値型が`return`文のオペランドで直接構築されているような場合です。

```cpp
struct S {
  S() = default;
  S(int);
};

auto f1() -> S {
  // コピー省略の対象となるreturnの例
  return {};    // prvalue
  return S{};   // prvalue
  return 10;    // prvalue
  return {10};  // prvalue

  S s{};

  // コピー省略の対象とならない例
  return s; // lvalue
  return std::move(s); // xvalue
}
```

その上で、関数の戻り値型と呼び出し側で戻り値を受けている変数の型が同じ型（CV修飾は無視する）である必要があります。

```cpp
struct log {
  log() {
    std::cout << "default ctor\n";
  }

  log(const log&) {
    std::cout << "copy ctor\n";
  }
};

struct V {
  V(log) {
    std::cout << "convert ctor\n";
  };
};

auto f() -> log {
  return {};
}

int main() {
  auto r1 = f(); // コピー省略される
  std::cout << "-----\n";
  log r2 = f();  // コピー省略される
  std::cout << "-----\n";
  V r3 = f();    // コピー省略されない
}
```

このコードをC++17モードのコンパイラでコンパイルし実行すると、次のような出力が得られます

```{style=planetext}
default ctor
-----
default ctor
-----
default ctor
convert ctor
```

`r1, r2`は変数の型が推論されているかの違いがあるだけで同じことをしています。この場合、コピー省略前は変数初期化のために戻り値からのコピー構築が必要だったのが省略されるようになりました。`r3`は変数の型が`f()`の戻り値型と異なるため、変換コンストラクタの呼び出しを省略することができず、`V`の変換コンストラクタが追加で呼ばれています。ただし、正確には`f()`の戻り値から`V`の変換コンストラクタの引数へのコピーは省略されており、そこにはコピー省略が起きています。

この例を見るとわかるように、コピー省略が行われるとそのコンストラクタ呼出（及びデストラクタ呼び出し）は問答無用で省略されます。この`log`のコピーコンストラクタは明らかに観測可能な副作用を持っていますが、コピー省略が行われるかはコンストラクタとデストラクタがどのような副作用を持っているかによりません。例えば、コピー/ムーブコンストラクタが`delete`され本来構築後に移動できないような型でもコピー省略が行われれば`return`文から返すことができます。

```cpp
struct N {
  N() = default;
  
  // コピーもムーブもできない
  N(const N&) = delete;
  N(const N&&) = delete;
};

auto f() -> N {
  return {};  // コピー省略によって戻り値からのコピーが省略される
}

int main() {
  N n = f();  // ok（C++14以前はエラーになる可能性がある）
}
```

C++17以降、このようなコピー省略（RVO）は必須とされています。従って、C++17以降のコピー省略はもはや最適化ではなく言語に組み込まれたデフォルトの振る舞いです。

## コピー省略と*prvalue*

規格においては、コピー省略は*prvalue*の伝播という形で定義されています。

*prvalue*とは式の値カテゴリの1つであり、リテラルやクラス型の初期化式、組み込み演算子の結果などが持つ値カテゴリです。これはC++14までは一時オブジェクトと呼ばれるものでもあったのですが、現在は一時オブジェクトになる前の何かのことで、*prvalue*はまだオブジェクトではありません。

```cpp
// prvalue式の例
// 式を例示するため;を付けていない

std::vector<int>{} // クラス型の初期化式
0  // リテラル

int a = 0, b = 1;

// 組み込み演算子の使用
a + b
&a
++a

auto f() -> std::vector<int>;

f() // 非参照戻り値型の関数呼び出し
```

*prvalue*とは*pure rvalue*の略で、この例のように左辺値を`std::move`したもの（*xvalue*）ではない、生まれながらの右辺値のことを指しています。*prvalue*が何かというのは非常に難しいのですが、*prvalue*はオブジェクトを初期化する式でありその結果は初期化される対象オブジェクトの値となるものです。対して左辺値式（*glvalue*）は必ずしもオブジェクトを初期化する式ではなく、その結果はオブジェクトであり、左辺値式はその式の結果の値がどこにあるかを返す式です（ここでは、オブジェクトとその値という言葉が使い分けられていることに注意してください。値とはオブジェクトの状態のことを指す抽象的なもののことで、オブジェクトとはその値がどこかのストレージに保存されている場合に値+位置の情報を持つ実体のことです）。

通常のプログラミングにおいて式の評価やその値カテゴリなどの概念はその結果（オブジェクト）に関するものだと理解されており、その理解でもC++プログラミングのほとんど全ての場合に支障がないメンタルモデルを構築することができます。その理解に基づくならば、*prvalue*とは結果を計算する前の式そのものであると思うのがわかりやすいかもしれません。

*prvalue*は実体化を受けることによって一時オブジェクトになり、その変換のことを一時オブジェクトの実体化変換（*Temporary materialization convertion*）と呼び、また単に*prvalue*の実体化とも呼ばれます。*prvalue*が実体化するのは次の場合です

- *prvalue*が参照に束縛される場合
- クラス型の*prvalue*を介してメンバアクセスが行われる場合
- 配列型の*prvalue*がポインタ型への変換（減衰）を受ける場合
- 初期化子リストから`std::initializer_list<T>`オブジェクトが初期化される場合
- *prvalue*が`typeid/sizeof`のオペランドとなる場合
- *prvalue*が廃棄される場合

一時オブジェクトの実体化変換によって*prvalue*は*xvalue*となります（型としては`T -> T&&`のようになる）。

```cpp
struct S {
  int n;
};

int main() {
  auto&& r = S{}; // prvalue（S{}）はxvalueに実体化され参照が束縛される（寿命は延長される）
  int k = S{}.n;  // prvalueは実体化されxvalueとなる
  S{};  // 実体化されデストラクタが呼ばれる
}
```

これら以外のところでは*prvalue*は実体化されず*prvalue*は*prvalue*のまま伝播され、*prvalue*が実体化されるコンテキストが制限されていることによって*prvalue*の実体化は可能な限り遅延されます。そして、*prvalue*はオブジェクトではなく、*prvalue*が*prvalue*のまま伝播していく際にコピーやムーブは発生しません。*prvalue*を評価される前の式そのものだと思うと、*prvalue*が*prvalue*のまま伝播していくというのは式がそのまま伝播していくということであり、*prvalue*式が大元の*prvalue*式で置換されていく形になります。

とはいえ*prvalue*が*prvalue*のまま伝播するコンテキストというのもかなり少なく、型が`T`（クラス型）の*prvalue*式`expr`に対する`T{expr}`や`T(expr)`のような`T`による変換式（これもまた*prvalue*）や`T`の初期化式（コピー初期化式）くらいです。この場合、`expr`は`T`の変換を素通りし、本来呼ばれるコンストラクタやデストラクタの呼び出しは省略されます。ただし、このようなコンテキストは将来的に追加される可能性があります。

*prvalue*が実体化を受けずにそれ以上伝播することができなくなった時、そこでその*prvalue*は初期化のために使用されます。もしもそれが何か初期化に使用されないならば、実体化後に破棄されます。*prvalue*を評価前の式そのものと思う場合は、*prvalue*式はそれ以上伝播できないところまで行き着くとようやく評価され、その値が取得され何かを初期化するのに使用されます。それはあたかも、大元の*prvalue*式でそれを囲む最も外側の*prvalue*式を置換したかのように評価されます。

```cpp
// クラス型Tがあるとして

// prvalueを返す関数
auto f() -> T {
  return T{...};  // prvalueを返すreturn文
}

int main() {
  T t1{f()}; // return文のprvalueがそのまま伝播し
  T t1{...}; // このような式として実行される

  T t2 = f(); // return文のprvalueがそのまま伝播し
  T t2{...};  // このような式として実行される

  T t3 = T{T{T{T{f()}}}}; // prvalue式がネストしていても
  T t3{...};              // このような式として実行される
}
```

`f()`の`return`文においては、まず戻り値の初期化が`return`文のオペランドの*prvalue*で行われ、戻り値そのものも*prvalue*であることから戻り値の初期化はスキップされ、`return`文のオペランドである*prvalue*が呼び出し元まで実体化されずに伝播します。`T{f()}`のような式は、`f()`という*prvalue*を受けて同じ型`T`の*prvalue*を生成する式です。`T{T{}}`も同様で、このような場合は*prvalue*は実体化されず*prvalue*のまま伝播し、仮に`T`のコンストラクタにいかなる副作用があったとしてもコンストラクタ呼び出しは省略されます。これによって、`f()`の`return`文のオペランドはその戻り値を受けている変数を直接初期化するようになります。

前述のように、*prvalue*が実体化せずに素通りできる式はその*prvalue*と同じ型（非参照かつCV修飾は無視）の*prvalue*式に限るため、例えば`U{f()}`のように型が異なると`U`の変換コンストラクタもしくは`T`変換演算子の引数で`f()`の戻り値である*prvalue*が実体化（参照引数の場合）するかオブジェクト初期化に使用（非参照引数の場合）されます。そのため、それらの変換関数の呼び出しは省略されません。この時、*prvalue*がオブジェクト初期化に使用される（呼ばれるコンストラクタ/変換演算子の引数が非参照の）場合、そこでもコピー省略は発生します。

```cpp
struct U {
  // Tを参照で受ける
  U(T); // prvalueを渡すとコピー省略が行われる
};

struct V {
  // Tを非参照で受ける
  V{T&&}; // prvalueを渡してもコピー省略は行われない
};

int main() {
  // これらは、Tのデフォルトコンストラクタ1回とUの変換コンストラクタ1回の呼び出し
  // Uの変換コンストラクタ引数の構築時にはコピー省略が行われる
  U u{T{}};

  // Vの変換コンストラクタ引数の構築時にはコピー省略が行われない
  // とはいえコンストラクタ呼び出しの回数は変わらない
  V v{T{}};
}
```

`T{f()}`のようにソースと宛先の型が同じ*prvalue*式の場合は、そのコンストラクタの呼び出しを考慮する前の段階でそれがスキップされることで*prvalue*がそのまま伝播し、そのコンストラクタ引数初期化のために伝搬が途切れません。

前述のように、*prvalue*がそのまま伝播するのは同じ型同士の変換式くらいであり、*prvalue*を受け取り*prvalue*を返すような関数の呼び出しは省略されません。別の言い方をすると、コピー省略によってスキップされるのはコンストラクタ/デストラクタ呼び出しのみです。

```cpp
struct log {
  log() {
    std::cout << "default ctor\n";
  }

  log(const log&) {
    std::cout << "copy ctor\n";
  }
};

auto f(log l) -> log {
  return l;
} 

int main() {
  auto l = log{f(log{})};
}
```

```{style=planetext}
default ctor
copy ctor
```

この場合、`f()`の引数の構築までは*prvalue*がそのまま伝播しコピー省略が発生しますが、`f()`の呼び出しは省略されずに`return`文でコピーが発生します。そして、`f()`は*prvalue*を返すのでその戻り値を受ける`log{}`は省略されます。

コピー省略は確かに`return`文における不要なコピーを省略するための仕組みであり`return`文において最も出会うことになりますが、この*prvalue*伝播のルールは何も`return`文に限ったものではありません。そのため、言語の他のコンテキストでもコピー省略が行われる場所があります。

その最も頻出し最も意外なものは、コピー初期化と呼ばれる初期化構文でしょう。

```cpp
// logは前のサンプルコードと同一

int main() {
  log l = log{};  // コピー初期化
}
```

これをコピー省略を無効化するオプション（`-fno-elide-constructors`）をつけたgcc12.2で最適化なしでC++11モードでコンパイルし実行すると次のような結果が得られます

```{style=planetext}
default ctor
copy ctor
```

このような形の初期化（`T t = init;`）のことをコピー初期化と呼び、これはあくまで右辺の一時オブジェクトをコピー（ムーブ）して左辺のオブジェクトを初期化するものです。そのため、右辺の初期化式が*prvalue*であり、左辺のオブジェクトの型がそれと同じ型（CV修飾は無視）であれば、ここでもコピー省略が行われます。

コピー初期化の形の初期化式でコピー省略が行われると、コピー初期化は直接初期化（`T t{init};`）として初期化されます。それによって、このコードの結果はデフォルトコンストラクタ1回の呼び出しだけを行うようになります。

```cpp
// logは前のサンプルコードと同一

int main() {
  log l = log{};  // これはコピー省略によって
  log l{};        // このように初期化される

  log l2 = l; // lは左辺値なのでコピー省略は行われない
}
```

C++17以降はコピー省略が保証されるため、コピー初期化のこのような非効率性を気にする必要はありません。C++14まででも、コンパイラはそれを積極的に省略していたのであまり気にしなくてもいいでしょう。

もう1つのコピー省略が発生するコンテキストは`throw`式です。

```cpp
// logは前のサンプルコードと同一

[[noreturn]]
void f() noexcept(false) {
  throw log{};  // オペランドをコピーして例外オブジェクトを初期化
}

int main() {
  try {
    f();
  } catch (const log&) {}
}
```

これをコピー省略を無効化するオプション（`-fno-elide-constructors`）をつけたgcc12.2で最適化なしでC++11モードでコンパイルし実行すると次のような結果が得られます

```{style=planetext}
default ctor
copy ctor
```

`throw`式ではそのオペランドを用いてコード上からは不可視の例外オブジェクトを構築して、その例外オブジェクトをより外側のハンドラでキャッチすることが行われます。この時、`throw`式のオペランドが*prvalue*ならば、例外オブジェクトの構築においてコピー省略が行われます。

```cpp
// logは前のサンプルコードと同一

[[noreturn]]
void f() noexcept(false) {
  throw log{};  // 例外オブジェクトを直接初期化（コピー省略）
}

[[noreturn]]
void g() noexcept(false) {
  log l{};
  throw l;  // オペランドをコピーして例外オブジェクトを初期化
}

int main() {
  try {
    f();
  } catch (const log&) {}

  std::cout << "-----\n";

  try {
    g();
  } catch (const log&) {}
}
```

これをそのままC++17モード（以降）でコンパイルすると、次のような結果が得られます

```{style=planetext}
default ctor
-----
default ctor
copy ctor
```

こちらのコピー省略もC++17以降で保証されています。

より本質的には

1. *prvalue*という一時オブジェクト未満の何かを指す値カテゴリ
2. オブジェクトを初期化する*prvalue*式の評価結果は初期化されたオブジェクトそのもの
    - `T{expr}`の形の式（`T`への変換式）は*prvalue*となり、評価結果のオブジェクトは`expr`によって直接初期化される
      - これによって、`T t{T{expr}};`は`T t{expr};`となる
    - *prvalue*によるコピー初期化はその*prvalue*による直接初期化となる
      - これによって、`T t = expr;`は`T t{expr};`となる
3. *prvalue*実体化コンテキストの制限
    - *prvalue*実体化は可能な限り遅延される

これらの仕組みによってC++17以降のコピー省略保証は達成されています。コピー省略は`return`文だけのためのものではなく、`return`文が特別扱いされているわけでもありません（`return`文において戻り値はコピー初期化によって初期化され、非参照戻り値型関数の呼び出し式は*prvalue*となる、ということを思い出してみてください）。また、`throw`式における例外オブジェクトの構築はそのオペランドを用いたコピー初期化によって行われています。

## NRVO

`return`文におけるコピー省略はそのオペランドが*prvalue*である場合にのみ保証されています。例えばローカル変数名を`return`文のオペランドにする場合（オペランドは左辺値）などにはRVOのようなコピー省略は保証されません。

```cpp
// Tは何かクラス型とする

auto f() -> T {
  T m = ...;

  ...

  // ローカル変数返す
  return m; // オペランドは左辺値
}

T main() {
  T r = f(); // コピー省略は行われない（保証されない）
}
```

このような場合にもコピー省略を行うのがNamed Return Value Optimization(NRVO)です。

NRVOによるコピー省略が行われた場合、関数内で`return`から返される変数名（上記例では`m`）と呼び出し側で戻り値を受けている変数名（上記例では`r`）があたかも同じオブジェクトを指しているかのように扱われ、`return`文の前後でそれらの変数及び戻り値の初期化/破棄の処理は発生しなくなります。

起こることのイメージとしては、関数引数に戻り値を受けている変数への参照を受けて、`return`文のオペランドとなっている変数への代入をそちらに行うようにする感じのことが起こります。

```cpp
void f(T& r) {
  r = ...;

  ...
}

int main() {
  T r;
  f(r);
}
```

NRVOが行われた場合に関数がこのような書き換えられるわけではありません。あくまでイメージです。

NRVOはC++規格において許可されているものの保証されてはいません。そのため、これはコンパイラの最適化の一環として行われ、いつどこで行われるかはコンパイラの裁量によります。このため、コピーもムーブもできないクラス型をNRVOを期待する形で関数から返すことができません。

```cpp
struct N {
  N() = default;
  
  // コピーもムーブもできない
  N(const N&) = delete;
  N(const N&&) = delete;
};

auto f() -> N {
  N n{};

  return n;  // ng、NRVOが行われたとしてもエラー
}
```

C++標準で許可されているNRVOは、`return`文のオペランドが変数名であり、その変数は関数ローカルの非`volatile`変数であり、かつ関数引数でも`catch`節のパラメータでもない、場合に許可されます。

```cpp
auto f() -> T {
  volatile T t{};

  return t; // NRVOは行われない
}

auto f(T t) -> T {

  return t; // NRVOは行われない
}
```

NRVOに対して`return`文で保証されたコピー省略（RVO）のことをUnnamed Return Value Optimization（URVO）と呼ぶこともあります。本来の意味としてはRVO=URVO+NRVOが正しいのですが、このあたりの用語はよく混同されて使用されてしまっています。

### NRVOが困難となる場合

NRVOはごく単純なケースでも困難となる場合があります。

```cpp
auto f(bool b) -> T {
  T t{};

  if (b) {
    return t;   // NRVOは行われない可能性がある
  } else {
    return {};  // コピー省略は保証される
  }
}
```

NRVOは関数内の全ての`return`文から同じ変数（オブジェクト）を返しているときはほぼ確実に行われますが、`return`文がそれぞれ異なるものを返しているとNRVOは困難になります。

```cpp
// NRVOが困難となるような関数の例
auto f() -> T {
  T t1{...};

  ...

  if (...) {
    return t1;
  }

  T t2{...};

  if (...) {
    return t2;
  }

  T t3{...};

  ...

  if (...) {
    return t3;
  } else if (...) {
    return t2
  }

  return {};  // コピー省略は保証される
}
```

こういう関数はNRVOが行われづらくなります。このことは単純に、関数の`return`が増えるほどNRVOが行われにくくなると思っても差し支えないでしょう。回避するには、全てコピー省略可能な形で書くか、戻り値用に1つの変数を用意して全ての`return`からそれを返す、などがあります。ただし、それはそれで別の非効率さを導入する可能性もあるので一筋縄ではありません。

これらのことはNRVOが保証されていない理由でもあります。全ての`return`から同じものを返しているときはNRVOを保証しようとする提案もありますが、まだ採択には至っていません。

### `return`文以外の場所でのNRVO

それはもはやNRVOではありませんが、RVOと同様にNRVOと同等のコピー省略が行われる`return`分以外の場所がいくつかあります。

まず1つはRVOと同様に`throw`式です。

```cpp
[[noreturn]]
void f() noexcept(false) {
  T t{...};

  throw t;  // コピー省略が行われる可能性がある
}
```

次の1つは`catch`節です。

```cpp
// f()は1つ前のもの

int main () {
  try {
    f();
  } catch (T ex)  // コピー省略が行われる可能性がある
  {
    ...
  }
}
```

前提としてどちらの場合もコピー省略対象のオブジェクトの型と例外オブジェクトの型が同じ（CV修飾は無視）でなければなりません。その上で、`throw`式で行われるのはそのオペランドから例外オブジェクトを初期化する際のコンストラクタ呼び出しで、`catch`節で行われるのは例外オブジェクトから`catch`節のパラメータを初期化する際のコンストラクタ呼び出しです。

例外オブジェクトはコード上からは不可視のオブジェクトで、スタック巻き戻しから安全な領域に構築されています。`throw`式でおこるコピー省略では関数におけるNRVOと同様に考えることができますが、`catch`節で起こることは少し異なっています。`catch`節においてコピー省略が行われるとその`catch`節内でキャッチした例外オブジェクトヘのアクセスは、どこかに構築されている例外オブジェクト本体を直接参照することになります。

```cpp
// f()は1つ前のもの

int main () {
  try {
    f();
  }
  catch (T  ex) {}  // コピー省略が行われるとこれは
  catch (T& ex) {}  // このハンドラと実質的に同じ
}
```

したがってこの時、この例外オブジェクトに変更を加えてそれを観測可能にしてしまうことが起こる場合、`catch`節におけるコピー省略は無効になります。そのもっとも単純なケースは、例外オブジェクトを再スローする場合です。

```cpp
void f() {
  throw std::string{"exception"};
}

void g () {
  try {
    f();
  } catch (std::string s) // ハンドラ内コードによってコピー省略は無効化される
  {
    // キャッチした例外オブジェクトを変更し
    s += " catch!";

    // 現在の例外オブジェクトを再スローする
    throw;
  }
}
```

`catch`節におけるコピー省略はそのキャッチ対象の型が例外オブジェクトの型と同じ型`T`の非参照型で宣言されている場合にのみ起こりますが、コピー省略が行われる場合は参照でキャッチしている時と同じことになるため、`catch`節における宣言型についてはあまり気にしなくてもいいかもしれません。

`return`文外でNRVO相当のコピー省略が行われる場所の最後の一つは、コルーチン呼び出し時の引数です。

```cpp
// 何かコルーチンとする
auto f(T t) -> task<int> {
  ...
}

int main() {
  T t{...};

  int n = co_await f(t);  // tのコピー省略が行われる可能性がある
}
```

コルーチンはその呼び出し時に実引数やコルーチンハンドル等の最小限の状態をコルーチンステートとしてどこかの領域（通常は動的確保した領域）に保存します。その際に渡した引数はコルーチンステート内に転送（コピー/ムーブ）されますが、この引数がコルーチン内で使用されていないかコルーチンが動的確保を行わないように最適化された場合、コルーチンステートへの転送に伴うコンストラクタ呼び出しが省略されます。

コルーチンの場合のコピー省略は他の場合と少し異なるものですが、分類としてはNRVOと同等の最適化とされています。

## `return`文における`std::move()`

`return`文のオペランドに対して`std::move()`してしまうと、RVO/NRVO問わずコピー省略が妨げられます。この理由は複雑でわかりづらいものがありますが、ここまで説明してきたことを頭に入れると理解することができます。

まずRVOの場合は割と単純で、これは`std::move()`が*prvalue*の伝播を妨げてしまうためです。

```cpp
auto f() -> T {
  return std::move(T{});  // コピー省略は行われない
}
```

`std::move()`は関数呼び出しであるためその呼び出しをスキップすることができず、`std::move()`の引数（右辺値参照型`T&&`）を初期化するために*prvalue*の実体化が起き、その戻り値は*xvalue*となります。これによって、`return`文は戻り値初期化のために`T{}`で構築されたオブジェクトをムーブします。

`std::move()`は次のようなライブラリ関数であり、その引数は参照で受け取られ、戻り値は*xvalue*（`T&&`）を返します。

```{style=cppstddecl}
// std::move()の宣言
namespace std {
  template <class T>
  constexpr remove_reference_t<T>&& move(T&& t) noexcept;
}
```

`std::move()`の処理実態は単なるキャストなのですが、これはあくまでライブラリ関数であるため言語機能から特別扱いされてはいません。そのため、定数評価やインライン化が行われたとしても、それ以前の段階で判断される言語機能としてのコピー省略はこれを関数呼び出し以上のものとして扱うことができません。

NRVOの場合は`return`文のオペランドに対して値カテゴリの要求が無いため、一見するとこれは問題とならないように見えます。しかし、NRVOの場合は`return`文のオペランドが丁度変数名でなければなりません。そうでなければ、NRVO対象の変数を認識できません。

```cpp
auto f() -> T {
  T t{...};

  return std::move(t);  // コピー省略は行われない
}
```

これらのことは結局、`std::move()`が単なるライブラリ関数でしかないために起こることです。`std::move()`の呼び出しをユーザー定義の任意の関数`m()`である場合、おそらくそこでコピー省略が起こらないことは簡単に理解できるでしょう

```cpp
// ユーザー定義関数
template<typename T>
auto m(T&& t) -> std::remove_reference_t<T>&& {
  ...
}

auto f1() -> T {
  return m(T{});  // コピー省略は行われない
}

auto f2() -> T {
  T t{...};

  return m(t);    // コピー省略は行われない
}
```

`return`文のオペランドからでは関数`m()`が何をするものなのか分からず、分かったとしてもこれをスキップすることは許可されていません。これは`std::move()`にも言えることで`std::forward()`でも同様です。つまりは、`std::move()`が実際には普通のユーザー定義関数と扱いが全く変わらないことから来ています。

なお、`std::move()`に関しては、コンパイラはそれが無ければコピー省略が行える場合にそれを妨げているとして警告してくれます。

### `return`文内の`std::move()`が有効な場合

`return`文で戻り値を構築する際に基本的には`std::move()`は必要ありませんが、直接的ではなく間接的に必要となる場合があります。それは、`return`文のオペランドで呼び出している関数/コンストラクタの引数として渡す変数をムーブしたい場合で、この場合は暗黙ムーブの対象でもコピー省略の対象でもないため明示的に`std::move()`が必要となります。

```cpp
auto f1() -> std::pair<int, std::string> {
  int n = ...;
  std::string str = "local string";

  return {n, str};            // strはコピーされてpairが構築される
  return {n, std::move(str)}; // strはムーブされてpairが構築される
}

auto g(std::string) -> std::string;

auto f2() -> std::string {
  std::string str = "local string";

  return g(str);            // strはコピーされてg()が呼び出される
  return g(std::move(str)); // strはムーブされてg()が呼び出される
}
```

このように`return`文のオペランドで戻り値を取得するために他の関数（コンストラクタ）呼び出しが必要となる場合に、その引数をムーブするためには`std::move()`をしなければ左辺値はムーブされません。前述のように、この場合にこの関数呼び出しをスキップするなどということは行われず、これは`std::move()`が`return`で直接呼ばれている場合にNRVOを妨げる理由にも共通しています。

## ABIから見たコピー省略

ここまで見てきた関数呼び出しとはあくまでC++の意味論によるもので、それを実際に実行するのはCPUの役割であり、そこではスタックとレジスタをやりくりして関数呼び出しを実現しています。その際にそのやりくりをどのように行うのかについてはABI（*Application Binary Interface*）によって定められており、特に関数呼び出し周りのABIの指定のことを呼び出し規約（*calling convention*）と呼びます。

そこでは、ほぼ全て（私の認識する限り）のABIにおいて、戻り値は特定のレジスタを使用して返されます。

```cpp
int f() {
  return 10;
}
```

これをx64環境g++13.1で最適化なしでコンパイルすると、次のようなアセンブリが得られます（Compiler Explorerを利用しました）

```
push    rbp       # ベースポインタの保存
mov     rbp, rsp  # ベースポインタ更新
mov     eax, 10   # 戻り値初期化
pop     rbp       # ベースポインタ復帰
ret               # リターン
```

この場合3行目以外は関数呼び出しにお決まりの処理でありここでは触れません。3行目が戻り値の初期化を行なっているところで、`eax`レジスタに戻り値`10`を保存しています。x64（およびこの環境）のABIが定めるところにより、関数の戻り値は基本的に`rax`レジスタによって呼び出し側に返され、ここでは戻り値型`int`のサイズが32bitであることからその下位32bit部分である`eax`レジスタが戻り値返しに使用されています。`rax`（`eax`）レジスタは関数呼び出し先で少なくとも戻り値を配置するのに使用されるため、呼び出し側は関数呼び出し前と呼び出し後に`rax`レジスタの内容を退避（どこかにコピー）しておく必要があります。

```cpp
int main() {
  int n1 = f();
  int n2 = f();

  return n1 + n2;
}
```

```
push    rbp
mov     rbp, rsp
sub     rsp, 16
call    f()                     # 関数呼び出し1
mov     DWORD PTR [rbp-4], eax  # n1初期化
call    f()                     # 関数呼び出し2
mov     DWORD PTR [rbp-8], eax  # n2初期化
mov     edx, DWORD PTR [rbp-4]
mov     eax, DWORD PTR [rbp-8]
add     eax, edx                # main()戻り値の計算
leave
ret
```

2つ目の`f()`の呼び出しに注目すると、呼び出し前後で`eax`レジスタの内容を別の領域（スタック）にコピーしていることがわかります。

これはごく単純な例ですが、戻り値型が組み込み型のような単純な型であれば間に処理が挟まったとしてもこのように戻り値型を特定のレジスタに保存することが行われています。

とはいえ、レジスタのサイズには限界があり（例えば`rax`レジスタは64bit）、戻り値返しに使用するレジスタは関数呼び出し前後で退避（コピー）が発生するためクラス型の場合はそのコンストラクタとデストラクタの呼び出しが必要になります。そのため、ある一定以上のサイズのクラス型及びトリビアルではないクラス型については、戻り値のための領域を別に用意しておいて戻り値返しレジスタを介してそのポインタを渡すようにします。この別に確保される領域には通常スタック領域が使用されます。

```cpp
struct C {
  int n;

  C(int a) : n{a} {}
};

auto f() -> C {
  return {10};
}
```


## ムーブ省略？

コンストラクタの呼び出しについては、コピーコンストラクタ < ムーブコンストラクタの順で効率的というイメージがあり実際ムーブの方がコピーより非効率というケースは稀だと思われます。また、最適化については、何もしない < 暗黙ムーブ < コピー省略の順でより効率的です。

そして、`return`文においてのコピーコンストラクタの呼び出しをムーブコンストラクタ呼び出しに置き換えるのが暗黙ムーブであり、その上でそのムーブコンストラクタ呼び出しすら省略してしまうのがコピー省略です。

このように見ると、RVOの呼び方としてはコピー省略よりもムーブ省略の方がより適切かもしれません。とはいえ一般的（日本語圏に限らず）には既にRVO=コピー省略で広まっているのでわざわざ呼び方を変える必要はありませんが。

\clearpage


# 謝辞

本書を執筆するに当たっては以下のサイトをとても参照しました。サイト管理者及び編集者・執筆者の方々に厚く御礼申し上げます。

- cpprefjp(https://cpprefjp.github.io/ : ライセンスはCC-BY 3.0)
- cppreference(https://ja.cppreference.com/w/cpp : ライセンスはCC-BY-SA 3.0)
