---
title: C++20 言語機能編
author: onihusube
date: 2021/12/30
geometry:
  width: 188mm
  height: 263mm
#coverimage: cover.jpg
#backcoverimage: backcover.jpg
titlecolor:
  color1:
    r: 0.796078
    g: 0.949020
    b: 0.4
    c: 0.25
    m: 0.0
    y: 0.80
    k: 0.0
  color2:
    r: 0.207843
    g: 0.631373
    b: 0.419608
    c: 0.75
    m: 0.0
    y: 0.65
    k: 0.0
okuduke:
  revision: 初版
  printing: ねこのしっぽ
---
\clearpage

# はじめに

# 大きな機能

## `<=>`

### 符号付整数型の内部表現は２の補数であると規定


## コンセプト

### 特殊メンバ関数の条件付きトリビアル定義

## モジュール

## コルーチン

# 定数式

## 仮想関数

## `dynamic_cast/typeid`

## `try-catch`

## 共用体のアクティブメンバ切り替え

## トリビアルなデフォルト初期化

## インラインアセンブリ

## `consteval`

## `constinit`

## 動的メモリ確保

# テンプレート

## `auto`による関数テンプレートの簡易定義

## `typename`の省略

## クラス型の非型テンプレート引数

## 集成体テンプレートのCTAD

## エイリアステンプレートのCTAD

## `explicit(bool)`

# ラムダ式

## 暗黙のラムダキャプチャの簡易化（DR）

## テンプレート構文

## `[=, this]`

## ステートレスラムダ式のクロージャ型

## 評価されない文脈におけるラムダ式

## 初期化キャプチャのパック展開

## 構造化束縛した変数のキャプチャ

# 構造化束縛

## `static/thread_local`の許可

## 非公開メンバへのアクセス（DR）

## 呼び出す`get`メンバ関数の考慮の変更（DR）

# ユニコード文字型

## `char8_t`

## `char16_t/char32_t`

# 属性

## `[[no_unique_address]]`

## `[[likely]]/[[unlikely]]`

## `[[nodiscard("msg")]]`

## コンストラクタに対する`[[nodiscard]]`（DR）

# 集成体

## Designated Intilization

## `()`による集成体初期化

## ユーザー宣言コンストラクタの禁止

# 範囲`for`

## 初期化式の指定

## カスタマイゼーションポイント探索の変更（DR）

# その他

## Deprecating `volatile`

## ビットフィールドのデフォルトメンバ初期化

## `using enum`

## 入れ子`inline`名前空間定義の簡易化

## `__VA_OPT__`

## destroying operator delete

## 添字演算子内カンマの非推奨化

### C++23 Multidimensional subscript operator

# とてもマイナーな変更

## 関数テンプレートに明示的に型指定した場合にADLで見つからない問題を修正

- P0846R0 ADL and Function Templates that are not Visible (https://wg21.link/p0846r0)

関数テンプレートに明示的にテンプレートパラメータを与えて、なおかつADLによって発見されることを期待して呼び出した時、コンパイルエラーとなっていました。

```cpp
namespace N {
	struct A{};

	template <typename T>
	T func(const A&) { return T(); }
}

void f() {
	N::A a;
	func<int>(a); // ng
}
```

なぜかというと、テンプレートパラメータを指定する山かっこの`<`が比較演算子として扱われてしまうためです。そのため、上記のコードは`func`という何かと`int`を比較しようとしている（`func < int`）とみなされ、`func`は無い上に型名との比較は出来ないためコンパイルエラーとなります。このエラーメッセージは分かり辛く、`N::func`のように名前空間をきちんと指定すると起きなくなる（名前空間を指定すると正しく関数名だと分かるようになる）など非常に微妙な問題です。

C++20からは、ある名前について、修飾名・非修飾名探索で何も見つからないか関数が1つ以上見つかっており、その後に`<`が続いている場合に、その名前を関数テンプレート名であるとして特別扱いし、ADLが発動するようにします。それによって、上記のコードは`func`が関数テンプレート名だと認識されるためADLによって意図通りに動作するようになります。

これによる恩恵は、`std::get`をADL経由で呼び出そうとしたときに感じられるかもしれません。

```cpp
int main() {
  std::pair<int, double> p{1, 3.14};
  auto n = get<0>(p); // C++20よりok
}
```

なお、この変更によって関数を意図的に`<`の左側の引数として関数を受け取るようにオーバーロードされた`operator<`の呼び出しがコンパイルエラーとなるようになります。しかし、そのような例はあまりにも病的であるのでこの変更によるメリットの方が大きいと判断されました。

## 要素数不明の配列型への変換  

## 特殊化のアクセスチェック

## `default`コピーコンストラクタの`const`ミスマッチ

- P0641R2 Resolving Core Issue #1331 (const mismatch with defaulted copy constructor)  
  (https://wg21.link/P0641R2)

## const修飾されたメンバポインタの制限を修正

- P0704R1 Fixing const-qualified pointers to members (https://wg21.link/P0704R1)

# Defact Report

欠陥報告（*Defact Report* : DR）とは、仕様に対する欠陥（バグ）の報告に伴う解決のための提案であり、その変更は過去のバージョンに遡って適用されます。

ここまでにもいくつかDRとなる提案がありました（タイトルの後ろにDRと記載のあるもの）が、ここでは特にカテゴライズされないものを見ていきます。

DRとされた問題については一部のコンパイラは早期に実装している可能性があり、実装済みのコンパイラでは古いバージョンの指定時（C++20対応コンパイラに`-std=c++11`を指定するなど）にも変更が適用されてコンパイルされるようになります。ただし、DRがどのバージョンまで遡って適用されるかは指定されていない場合が多く、謎です・・・

## `new`式における配列要素数の推論

## ポインタ型から`bool`への変換を縮小変換とする

```cpp
struct A {
  bool b;
};

A f(int* p) {
  return {p}; // {}初期化では縮小変換は許可されない
}

int main() {
  int* p{};
  f(p); // ng
}
```

## 暗黙のムーブ対象の拡大

## 異なる例外指定がなされた`default`メンバ関数の許可

## トリビアルな型のオブジェクトを暗黙的に構築する

- P0593R6 Implicit creation of objects for low-level object manipulation (http://wg21.link/p0593r6)

## 不完全型を用いた宣言の抽象クラスのチェックを遅延する

- P0929R2 Checking for abstract class types (https://wg21.link/p0929r2)

抽象クラス（*abstract class*）とは、メンバ関数に純粋仮想関数が一つでもあるようなクラス型の事です。

```cpp
class abst {
  // メンバ変数があってもいい
  int m;

public:

  // コンストラクタがあってもいい
  abst(int n) : m(n) {}

  virtual ~abst() = default;

  // 1つでも純粋仮想関数があれば抽象クラス
  virtual void f() = 0;
};
```

抽象クラスは未定義の純粋仮想関数を含んでいるため、オブジェクトを作成することができません。抽象クラスのオブジェクトは、その派生クラスのオブジェクトの一部としてしか存在できず、抽象クラス型はポインタとして使用することになるでしょう。

しかし、不完全型を使用可能な他の文脈では不完全型として抽象クラス型が使用される可能性があり、そのように使用された場合に後から定義を追加すると、以前はエラーの出なかった宣言が遅れてコンパイルエラーを引きおこしていました。

```cpp
struct S;

S f();   // #1、関数宣言における不完全型の使用、ok

// 数百行の後・・・

// 抽象クラスの定義、#1を遡ってエラーにする
struct S { virtual void f() = 0; };
```

このほかにも、配列の宣言などにおいても同様の事が発生します

P0929はこの問題を解決するものであり、関数や配列などの宣言の時点では抽象クラスが使用されてもそこではその抽象性をチェックせず、その関数や配列が実際に定義されたとき（あるいは関数が呼び出されたとき）に初めてチェックされコンパイルエラーが発生するようにする、というものです。

これによる恩恵はおそらく、テンプレートメタプログラミングの文脈でテンプレート実引数として抽象型が使用されたときに不要なエラーが起こらなくなるという形で得られるでしょう。

# 謝辞

本書を執筆するに当たっては以下のサイトをとても参照しました。サイト管理者及び編集者・執筆者の方々に厚く御礼申し上げます。

- cpprefjp(https://cpprefjp.github.io/ : ライセンスはCC-BY 3.0)
- cppreference(https://ja.cppreference.com/w/cpp : ライセンスはCC-BY-SA 3.0)
- yohhoyの日記(https://yohhoy.hatenadiary.jp/)

表紙は友人のKさんに書いていただきました。可愛いキノコをありがとうございました！