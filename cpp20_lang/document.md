---
title: C++20 言語機能編
author: onihusube
date: 2021/12/30
geometry:
  width: 188mm
  height: 263mm
#coverimage: cover.jpg
#backcoverimage: backcover.jpg
titlecolor:
  color1:
    r: 0.796078
    g: 0.949020
    b: 0.4
    c: 0.25
    m: 0.0
    y: 0.80
    k: 0.0
  color2:
    r: 0.207843
    g: 0.631373
    b: 0.419608
    c: 0.75
    m: 0.0
    y: 0.65
    k: 0.0
okuduke:
  revision: 初版
  printing: ねこのしっぽ
---
\clearpage

# はじめに

# 大きな機能

## `<=>`

### 符号付整数型の内部表現は２の補数であると規定


## コンセプト

### 特殊メンバ関数の条件付きトリビアル定義

## モジュール

## コルーチン

# 定数式

## 仮想関数

## `dynamic_cast/typeid`

## `try-catch`

## 共用体のアクティブメンバ切り替え

## トリビアルなデフォルト初期化

## インラインアセンブリ

## `consteval`

## `constinit`

## 動的メモリ確保

# テンプレート

## `auto`による関数テンプレートの簡易定義

## `typename`の省略

## クラス型の非型テンプレート引数

## 集成体テンプレートのCTAD

## エイリアステンプレートのCTAD

## `explicit(bool)`

# ラムダ式

## 暗黙のラムダキャプチャの簡易化（DR）

## テンプレート構文

## `[=, this]`

## ステートレスラムダ式のクロージャ型

## 評価されない文脈におけるラムダ式

## 初期化キャプチャのパック展開

## 構造化束縛した変数のキャプチャ

# 構造化束縛

## `static/thread_local`の許可

## 非公開メンバへのアクセス（DR）

## 呼び出す`get`メンバ関数の考慮の変更（DR）

# ユニコード文字型

## `char8_t`

## `char16_t/char32_t`

# 属性

## `[[no_unique_address]]`

## `[[likely]]/[[unlikely]]`

## `[[nodiscard("msg")]]`

## コンストラクタに対する`[[nodiscard]]`（DR）

# 集成体

## Designated Intilization

## `()`による集成体初期化

## ユーザー宣言コンストラクタの禁止

# 範囲`for`

## 初期化式の指定

## カスタマイゼーションポイント探索の変更（DR）

# その他

## Deprecating `volatile`

## ビットフィールドのデフォルトメンバ初期化

## `using enum`

## 入れ子`inline`名前空間定義の簡易化

- P1094R2 Nested Inline Namespaces (https://wg21.link/p1094r2)

C++17より、ネストした名前空間定義を`A::B::C`のように`::`で繋げて簡略化することができます。しかし、`inline`名前空間はその対象ではなく、ネストした名前空間定義に`inline`名前空間が挟まると、その定義を分割しなければなりませんでした。

```cpp
// ほんとはこう書きたいけど
// namespace A::B::C { ... }
namespace A {
  // inline名前空間が間にあるので個別定義せざるを得ない
  inline namespace B {
    namespace C {
      int f(int n);
    }
  }
}
```

この制限は不便だったため、ネストした名前空間の簡易定義構文を拡張し、各段の名前空間名の前に`inline`キーワードを入れることでその名前空間を`inline`名前空間としてネストさせることができるようになります。

```cpp
namespace A::inline B::C {
  int f(int n);
}
```

この場合、`B`だけが`inline`名前空間となり、`A, C`は通常の名前空間となります。

## `__VA_OPT__`

- P0306R4 Comma omission and comma deletion (https://wg21.link/p0306r4)

可変引数マクロを実現する`__VA_ARGS__`は与えられた引数がゼロの場合には空で置換され、場合によっては可変引数が来ることを想定して置いておいたカンマが余ってしまうというようなことがありました。

```cpp
#define F(...) f(0, __VA_ARGS__)

F();  // f(0, );
```

この場合、プリプロセス後にコンパイルエラーとなります。これは地味に厄介な問題で、回避しようとすると複雑なことをしなければなりません、

C++20より、`__VA_OPT__(...)`を使用することでそのような問題を回避できます。

```cpp
#define F(...)           f(0 __VA_OPT__(,) __VA_ARGS__)

F(a, b, c); // f(0, a, b, c);
F();        // f(0);


#define SDEF(sname, ...) S sname __VA_OPT__(= { __VA_ARGS__ })

SDEF(foo);        // S foo;
SDEF(bar, 1, 2);  // S bar = {1, 2};
```

`__VA_OPT__(tokens...)`は`__VA_ARGS__`の数が0の時には空で置換され、1以上の時にかっこの中の`tokens...`へ置換されます。これによって、引数の数に応じてカンマを置く置かないなど柔軟な置換ができるようになります。

## destroying operator delete

## 添字演算子内カンマの非推奨化

- P1161R3 Deprecate uses of the comma operator in subscripting expressions (https://wg21.link/p1161r3)

C++では添字演算子（`[]`）は複数の引数をとることはできませんが、カンマ演算子（`,`）オーバーロードによって擬似的にそのようなことを行えます。これは一部のテンプレートEDSLライブラリなどにおいて活用されていました（実際にはオープンソースコードベースの調査ではそのようなコードは見つからなかったようです）。

C++20からは将来の添字演算子の可変長引数化に向けて、添字演算子にカンマ区切りで複数の引数を渡す事が非推奨とされます。同じように書きたい場合、`()`でそのようなカンマ区切りの引数リストを囲う事が推奨されます。

```cpp
template<typename A, typename I>
void f(A arr, I x, I y) {
  arr[x, y];    // C++20から非推奨
  arr[(x, y)];  // ok
}
```

非推奨化といってもコンパイルエラーとなるわけではありませんが、警告は出るようになるでしょう。

これは、`std::mdspan`（多次元配列版`std::span`）で可変長`[]`オーバーロードを提供するための変更の第一歩です。

### C++23 Multidimensional subscript operator

- P2128R6 Multidimensional subscript operator (https://wg21.link/p2128r6)

この変更に引き続いて、C++23では可変長引数添字演算子のオーバーロードが許可されます。それによって、`[]`の扱いは関数呼び出し演算子`()`と全く同一になります。

```cpp
int main() {
  int buffer[2*3*4]{};
  auto s = std::mdspan<int, std::extents<2, 3, 4>>(buffer);
  s[1, 1, 1] = 42;
}
```

## トリビアルな型のオブジェクトを暗黙的に構築する

- P0593R6 Implicit creation of objects for low-level object manipulation (https://wg21.link/p0593r6)

C++にはオブジェクトの生存期間（*lifetime*）という概念があり、オブジェクトは作成された時にその生存期間が開始されます。生存期間外のオブジェクトの操作は未定義動作となり、それによってC言語では問題のないプログラムがC++では未定義動作となることがあります。

```cpp
struct X { int a, b; };

X* make_x() {
  X *p = (X*)malloc(sizeof(struct X));
  p->a = 1;
  p->b = 2;
  return p;
}
```

このコードはCでは問題ありませんがC++では未定義動作となります。なぜなら、`malloc`によってメモリを確保した後、その領域に`X`のオブジェクトを作成していないからです。C++では次の場合にオブジェクトはその定義に従って作成されます

- `new`式
- 共用体のアクティブメンバ切り替え時
- 一時オブジェクトが作成される時

上記プログラムはこれらのことを何もしていないため、`p`に確保されたメモリ領域には`X`のオブジェクトが作成されていません。従って、`X`の定義に従ったオブジェクト操作は未定義動作となります。

この問題は、バイト列が与えられた時にその領域をある型のオブジェクトとして参照できるのか？という問題に帰結されます。これはファイルやネットワークからデータを読みだした後で頻出するパターンでもあります。多くの場合、そこでは単にポインタの読替えが行われます。

```cpp
void process(Stream *stream) {
  unique_ptr<char[]> buffer = stream->read();

  if (buffer[0] == FOO) {
    process_foo(reinterpret_cast<Foo*>(buffer.get())); // #1
  } else {
    process_bar(reinterpret_cast<Bar*>(buffer.get())); // #2
  }
}
```

このコードもまた未定義動作を起こします。`stream->read()`では`Foo, Bar`の両方のオブジェクトが作成されることはないので、どちらかが作成されていたとしても`if`文の片方のパスは未定義動作になります。そして多くの場合、このような場合に明示的にオブジェクトを構築するコードが書かれる事は稀でしょう。

とはいえ、これらのコードはCで同等のことをした時には問題がなく、当然動作すると仮定されていることです。そのため、このような場合に暗黙的にオブジェクトを作成する事でこれらのコードが未定義動作を含まず意図通りに動作することが保証されるようになります。

とはいえそれは全ての型について行えることではなく、バイト列からオブジェクトを作成することなく復元できるような型はごく単純な型であるはずです。C++20では次のカテゴリの型がその対象となります

- スカラ型
- 集成体型
  - 任意の要素型の配列型
  - 任意メンバの集成体クラス
- トリビアルに破棄可能かつトリビアルに構築可能なクラス型

これらに該当する型は*implicit-lifetime types*と呼ばれ区別され、一部の操作において明示的にオブジェクトを作成しなくても暗黙的にオブジェクトが作成されることによってバイト配列の読替えにおいて未定義動作を起こさなくなります。*implicit-lifetime types*は次の時にそのストレージ上にオブジェクトが暗黙的に作成されます

- `char, unsigned char, std::byte`の配列が作成された時
- `malloc, calloc, realloc`及び`operator new, operator new[]`の呼び出し後
- `memcpy, memmove`
- `std::bit_cast`

これに加えて`mmmap`(POSIX)や`VirtualAlloc`(WinAPI)などの実装定義のものが含まれます。ただし、`reinterpret_cast`はいかなる場合でもそのような動作をしません（つまり2つ目の例は相変わらず未定義動作となります）。

# とてもマイナーな変更

## 関数テンプレートに明示的に型指定した場合にADLで見つからない問題を修正

- P0846R0 ADL and Function Templates that are not Visible (https://wg21.link/p0846r0)

関数テンプレートに明示的にテンプレートパラメータを与えて、なおかつADLによって発見されることを期待して呼び出した時、コンパイルエラーとなっていました。

```cpp
namespace N {
	struct A{};

	template <typename T>
	T func(const A&) { return T(); }
}

void f() {
	N::A a;
	func<int>(a); // ng
}
```

なぜかというと、テンプレートパラメータを指定する山かっこの`<`が比較演算子として扱われてしまうためです。そのため、上記のコードは`func`という何かと`int`を比較しようとしている（`func < int`）とみなされ、`func`は無い上に型名との比較は出来ないためコンパイルエラーとなります。このエラーメッセージは分かり辛く、`N::func`のように名前空間をきちんと指定すると起きなくなる（名前空間を指定すると正しく関数名だと分かるようになる）など非常に微妙な問題です。

C++20からは、ある名前について、修飾名・非修飾名探索で何も見つからないか関数が1つ以上見つかっており、その後に`<`が続いている場合に、その名前を関数テンプレート名であるとして特別扱いし、ADLが発動するようにします。それによって、上記のコードは`func`が関数テンプレート名だと認識されるためADLによって意図通りに動作するようになります。

これによる恩恵は、`std::get`をADL経由で呼び出そうとしたときに感じられるかもしれません。

```cpp
int main() {
  std::pair<int, double> p{1, 3.14};
  auto n = get<0>(p); // C++20よりok
}
```

なお、この変更によって関数を意図的に`<`の左側の引数として関数を受け取るようにオーバーロードされた`operator<`の呼び出しがコンパイルエラーとなるようになります。しかし、そのような例はあまりにも病的であるのでこの変更によるメリットの方が大きいと判断されました。

## 要素数不明の配列型への変換  

- P0388R4 Permit conversions to arrays of unknown bound (https://wg21.link/p0388r4)

C++17まで、要素数が確定している配列型から要素数が不定の配列型への変換はできませんでした。この制限は特に理由があったものではないようで、撤廃されます。

要素数不明の配列型というのは、たとえば`extern`で宣言され別の翻訳単位に実体のある配列型などで存在しえます。そして、そのような配列型（のポインタ/参照）を引数に取る関数を宣言することもでき、そのような関数の実装は要素数を仮定した処理となっているはずです。その場合にそこに要素数が確定している配列を渡せることは自然であり、プログラマがその事前条件を満たすように注意すれば特に危険もありません。そのような用途で使用される可能性があり、有用性もあるために許可されるに至ったのだと思われます。

```cpp
extern int arr[];

// 要素数不明の配列への参照を引数に取る関数
void f(int (&)[]);

int main() {
  int arr2[2] = {1, 2};

  f(arr);   // ok
  f(arr2);  // C++20からok
}
```

オーバーロード解決における順序付けでは要素数が一致する候補が最優先され、要素数不明の配列型への変換とその選択は要素数が一致する候補が無い場合に行われます。また、要素型の変換が行われる場合は要素数が一致していなくても変換が起こらない候補が最優先されます。

```cpp
void f(int (&&)[]);     // #1
void f(float (&&)[]);   // #2
void f(int (&&)[2]);    // #3

int main() {
  f({ 1 });         // #1が選択される
  f({ 1.f, 2.f });  // #2が選択される
  f({ 1, 2 });      // #3が選択される
}
```

## 特殊化のアクセスチェック

- P0692R1 Access Checking on Specializations (https://wg21.link/p0692r1)

クラス内で宣言されているローカルクラスがプライベートメンバである時、テンプレートの文脈からそれを参照する際の仕様と実装の非一貫性が長いこと存在していました。

```cpp
template<class T>
struct trait;

class C1 {
  class impl; // クラス内ローカルクラス
};

// C++標準としては許可されない(implがprivateのため)
// しかし実際にはほぼ全てのコンパイラでエラーにならない
template<>
struct trait<C1::impl>;
```

プライベートローカルクラス型によるテンプレートの特殊化は、そのクラス外からは許可されません。しかし実際には、多くのコンパイラがそれを許可していました。ここで、このローカルクラス（`impl`）をローカルクラステンプレートにすると、コンパイラ間でも挙動に差異が生じます。

```cpp
template<class T>
struct trait;

class C2 {
  template<class U>
  struct impl;
};

// C++標準としては許可されない(implがprivateのため)
// ng : clang, icc
// ok : gcc, msvc
template<class U>
struct trait<C2::impl<U>>;
```

プライベートローカルクラステンプレートを用いて特殊化した上でクラス外から参照しようとすると、calngやiccでは許可されないのに対して、gcc,msvcでは許可されます。

C++20では、標準でプライベートローカルクラス（テンプレート）のテンプレートの文脈からの参照が許可され、標準と実装の差異及び実装間の差異がプログラマにとって望ましい形で解消されます。それによって、上記2種類のサンプルはどちらも標準仕様に則った正しいコードとなります。

```cpp
// C++20より、どちらもok

template<>
struct trait<C1::impl>;

template<class U>
struct trait<C2::impl<U>>;
```

これらのことは標準のいくつかの提案を実装しようとした時に問題となり、C++20での例として`<ranges>`の各種`view`のイテレータ型があります。`view`のイテレータ型はほとんどが`view`クラスのプライベートローカルクラステンプレートとして定義されており、この変更がなければそれらの型に対して`std::iterator_traits`をはじめとする`trait`テンプレートを適用する事が合法的かつポータブルに行えませんでした。

## `default`コピーコンストラクタの`const`ミスマッチを`delete`するようにする

- P0641R2 Resolving Core Issue #1331 (const mismatch with defaulted copy constructor)  
  (https://wg21.link/P0641R2)

コピーコンストラクタは通常クラス`C`に対して`const C&`の引数を持ちますが、実のところ意外と柔軟で`const`が無くても良かったりします。すると、他の型のオブジェクトをメンバとして持つクラス型では、それら及び自身のコピーコンストラクタの間で受け取る引数型のミスマッチが発生することになります。

```cpp
struct MyType {
  MyType() = default;
  MyType(MyType&);  // constがない
};

template <typename T>
struct Wrapper {
  Wrapper(const Wrapper&) = default;  // constあり

  T t;
};

Wrapper<MyType> var;  // ng
```

この場合、`Wrapeer<MyType>`のコピーコンストラクタ引数と`MyType`のコピーコンストラクタ引数とで`const`ミスマッチが発生しており、それによって`Wrapeer<MyType>`の`default`コピーコンストラクタが定義できなくなっています。コピーコンストラクタを使用していなくてもこれはエラーとなってしまいます。

なぜこうなるかというと、あるクラス`T`の`default`コピーコンストラクタはそれを明示的に宣言しないときに暗黙に定義されているコピーコンストラクタと同じ引数を持つ必要があり、メンバ型のコピーコンストラクタ引数が`const`無しである場合それに引きずられて`T`の暗黙のコピーコンストラクタは`T(T&);`の様に宣言されるためです。

`Wrapeer<MyType>`ではまさにこれが起きており、`Wrapper(Wrapper&) = default;`と宣言するとコンパイルエラーは起こらなくなります。

C++20では、このような場合にコピーコンストラクタは暗黙`delete`されるようになります。従って、コピーコンストラクタを使用しようとするまでエラーは出なくなります。これはコピー代入演算子等他の特殊メンバ関数にも適用されますが、代入演算子が非参照パラメータを持つ場合や戻り値型がおかしい場合などは引き続きその場でエラーとなります。

この問題が起こりうるラッパー型には`std::tuple`や`std::pair`があり、それらの使用時に非常にまれに恩恵を感じられるかもしれません。とはいえ、コピーコンストラクタは`const T&`を取るようにすべきでしょう。

## const修飾されたメンバポインタの制限を修正

- P0704R1 Fixing const-qualified pointers to members (https://wg21.link/P0704R1)

メンバ関数に参照修飾を行うと、そのオブジェクトの値カテゴリに応じて関数を呼び分けることができるようになります。これはC++11から可能になったのですが、メンバポインタまでその考慮が行き届いておらず、メンバポインタを介した呼び出しが意図通りにならない事がありました。

```cpp
struct X {
  void foo() const&;
};

X{}.foo();        // ok
(X{}.*&X::foo)(); // ng
```

この2つのコードは本質的に同じことをしているはずです。右辺値（*prvalue*）は`const`左辺値参照で束縛できるため、右辺値オブジェクトから`const &`修飾されたメンバ関数が呼び出せるのは自然な事です。しかし、`.*`演算子を使用したメンバポインタ呼び出しの仕様では、「`.*`を用いて右辺値オブジェクトに対してメンバ関数ポインタ呼び出しを行う場合、そのメンバ関数が`&`修飾されている場合呼び出しできない」のように指定されており、`const &`が考慮されていませんでした。

この変更によってそれが修正され、上記のコードはどちらも呼び出し可能となります。

これは、`std::invoke`の使用時に恩恵を感じることがあるかもしれません。`std::invoke`は統一的な関数呼び出しを行うものですが、その呼び出し方法の1つにメンバポインタからの呼び出しがあります。

# Defact Report

欠陥報告（*Defact Report* : DR）とは、仕様に対する欠陥（バグ）の報告に伴う解決のための提案であり、その変更は過去のバージョンに遡って適用されます。

ここまでにもいくつかDRとなる提案がありました（タイトルの後ろにDRと記載のあるもの）が、ここでは特にカテゴライズされないものを見ていきます。

DRとされた問題については一部のコンパイラは早期に実装している可能性があり、実装済みのコンパイラでは古いバージョンの指定時（C++20対応コンパイラに`-std=c++11`を指定するなど）にも変更が適用されてコンパイルされるようになります。ただし、DRがどのバージョンまで遡って適用されるかは指定されていない場合が多く、謎です・・・

## `new`式における配列要素数の推論

- Array size deduction in new-expressions (https://wg21.link/p1009r2)

配列の要素数について、動的ではない（`new`によらない）配列を`{}`によって初期化する際にはその要素数が初期化子の数から推定されます。しかし、同じことを`new`によって確保される配列に対して行うと要素数が推定できずにコンパイルエラーとなっていました。

```cpp
int a[] = {1, 2, 3};          // ok、要素数3
int* p = new int[]{1, 2, 3};  // ng、要素数が推定できない
```

配列初期化時の要素数推定はCのころからあったものですが、`new`式の仕様は少し複雑でそことは分かたれており、その考慮が`new`式にまで及んでいなかったようです。

これは単に見落とされていたもので、何か障害があったわけではありませんでした。多くのC++プログラマにとって`new`式における初期化は通常の変数の初期化と同じルールに従うことが自然でありこの非一貫性は直感的ではないため、修正することで初期化に関するルールがシンプルかつ教えやすくなります。とはいえ、`new`式で配列を書こうとすることは稀ではあるでしょう。

この提案は以前の全てのバージョンに対するDRであり、`clang`は早期にこれを実装していたようです。

## ポインタ型から`bool`への変換を縮小変換とする

- P1957R2 Converting from `T*` to `bool` should be considered narrowing (re: US 212) (https://wg21.link/p1957r2)

C++17で導入された`std::variant`には当初、ポインタから`bool`への暗黙変換によって意図しない構築がなされるバグがありました。

```cpp
std::variant<std::string, bool> x = "abc";  // boolを保持する
```

その後暗黙の`bool`変換を検出して弾くようにしたこと（P0608R3）でこのバグは解消されたのですが、今度は`bool`に変換可能なユーザー定義型が`bool`を選択して構築出来ないバグが導入されました。

```cpp
std::bitset<4> b("0101");
std::variant<bool, int> v = b[1]; // intを保持する
```

P0608R3による最初の修正時には他の問題の解決も含めていたため、代入時に縮小変換が起きる場合は構築できないようにされました。しかし、`bool`への暗黙変換の一部（特に`char* -> bool`への変換）を縮小変換として扱う事はライブラリレベルでは不可能だったため、`bool`への変換は全て禁止されていました。これによって2つ目のバグが導入されたわけです。

この解決のために、ポインタ型から`bool`への変換を縮小変換であるとコア言語で規定したうえで、`std::variant`の代入演算子の制約から`bool`への暗黙変換禁止を取り除きます。これによって、上記2つのコードはどちらも意図通りになることになります。

```cpp
std::variant<std::string, bool> x = "abc";  // std::stringを保持する

std::bitset<4> b("0101");
std::variant<bool, int> v = b[1]; // boolを保持する
```

この影響は`std::variant`だけではなく言語全体に波及し、ともすれば後方互換性を破壊する可能性があります。

```cpp
struct A {
  bool b;
};

A f(int* p) {
  return {p}; // ng、{}初期化では縮小変換は許可されない
}
```

この様な変換は多くの場合にバグである可能性が高いことから、コードの破損よりもそのような変換をコンパイル時に検出できるメリットの方が大きいと判断されたようです。なお、これはC++17へのDRです。

## 暗黙のムーブ対象の拡大

- P1825R0 Merged wording for P0527R1 and P1155R3 (https://wg21.link/P1825R0)
- P0527R1 Implicitly move from rvalue references in return statements (https://wg21.link/P0527R1)
- P1155R3 More implicit moves (https://wg21.link/P1155R3)

暗黙のムーブとは、ある関数から値をコピーして返す場合に暗黙的にムーブを行うことでコピーを回避する最適化の事です。C++17で規定された値のコピー省略保証（RVO）と似ていますが異なるもので、RVOは`return`されるオブジェクトを呼び出し側で直接構築することでコピーやムーブを完全に省くものです。

(N)RVO及び暗黙のムーブと呼ばれる最適化はC++11から許可されました。それが起こると関数からの`return`に際するコピーが省略され、コピーが一切できないような型のオブジェクトを関数から値で返すことができます。

```cpp
struct Widget {
  Widget(Widget&&);
};

Widget one(Widget w) {
  return w;  // 暗黙ムーブ、C++11から
}

struct RRefTaker {
  RRefTaker(Widget&&);
};

RRefTaker two(Widget w) {
  return w;  // 暗黙ムーブされて構築、C++11(CWG1579)
}
```

これらはC++11の時点で許可されていた暗黙のムーブによる最適化の一例です。関数ローカルの変数（値で宣言された関数引数）を自動でムーブして戻り値を返すことができます。

C++17までは、暗黙のムーブ対象は関数ローカルのオブジェクト（参照やポインタでない）だけでした。C++20からは、右辺値参照でバインドされたオブジェクトが暗黙のムーブ対象になるようになります。

```cpp
RRefTaker three(Widget&& w) {
  return w;  // 暗黙ムーブ、C++20(P0527)
}
```

さらに、暗黙のムーブが起こるコンテキストが拡張され、`throw`式やコンストラクタによらない暗黙変換が起こる場合にも暗黙のムーブが行われるようになります。

```cpp
void four(Widget w) {
  throw w;  // 暗黙ムーブ、C++20(P1155)
}

struct From {
  From(Widget const &);
  From(Widget&&);
};

struct To {
  operator Widget() const &;
  operator Widget() &&;
};

From five() {
  Widget w;
  return w;  // 暗黙ムーブ（コンストラクタによる変換）、C++11
}

Widget six() {
  To t;
  return t;  // 暗黙ムーブ（変換演算子による変換）、C++20(P1155)
}

struct Fowl {
  Fowl(Widget); // 値で受け取るコンストラクタ
};

Fowl seven() {
  Widget w;
  return w;  // 暗黙ムーブ、C++20(P1155)
}

// DerivedはBaseを公開継承しているとき
Base eight() {
  Derived result;
  return result;  // 暗黙ムーブ（基底クラスへの変換）、C++20(P1155)
}
```

暗黙のムーブが可能なローカル変数を`return`する時、その戻り値型を構築するためのオーバーロード解決において、対象変数を右辺値（*xvalue*）としてオーバーロード解決を行い、それによって選択されたコンストラクタ（変換関数）を選択することによって暗黙のムーブが実行されるようになります。

ただし、これら暗黙のムーブは値のコピー省略保証とは異なり必ず実行されるものではなく、あくまでコピー省略による最適化を明示的に許可するものであり、実装によっては行われない可能性があります。

## 異なる例外指定がなされた`default`メンバ関数の許可

- P1286R2 Contra CWG DR1778 (https://wg21.link/P1286R2)

`std::atomic<T>`はデフォルトコンストラクタを持ち、それは常に`noexcept`指定されています。

```cpp
template<typename T>
struct atomic {
  atomic() noexcept = default;

  // ...
};
```

このため、`T`のデフォルトコンストラクタが例外を投げうる（`noexcept`指定が無い）場合に要素型のデフォルトコンストラクタの`noexcept`指定とのミスマッチが発生し、デフォルトコンストラクタを使用するとコンパイルエラーとなっていました。

```cpp
struct S {
  S() noexcept(false) {}
};

int main() {
  std::atomic<S> s{}; // ng
}
```

これは、`default`宣言する特殊関数の例外指定はその宣言がないときに暗黙に定義される特殊関数のものと同じにならないといけないというルールによります（少し前で、コピーコンストラクタについても似たような制限がありました）。

ユーザーが明示的に指定した例外指定はそれが意図する例外指定なのでそれを受け入れるべきであり、この制限は取り除かれることになりました。これによって上記コードはコンパイルエラーとならなくなります。異なっている例外指定については上書きしているもの（`std::atomic`のもの）が優先され、`noexcept`指定されている特殊関数内でされていない関数が例外を投げた場合、プログラムは`std::terminate`によって停止します。

また、この問題及び解決はデフォルトコンストラクタのみではなく`default`指定可能な特殊メンバ関数全てに共通することです。

これはDRですが特にバージョン指定されておらず、この問題の原因となる変更が入ったのがC++14からなので、おそらくC++14に向けてのDRです。

## 不完全型を用いた宣言の抽象クラスのチェックを遅延する

- P0929R2 Checking for abstract class types (https://wg21.link/p0929r2)

抽象クラス（*abstract class*）とは、メンバ関数に純粋仮想関数が一つでもあるようなクラス型の事です。

```cpp
class abst {
  // メンバ変数があってもいい
  int m;

public:

  // コンストラクタがあってもいい
  abst(int n) : m(n) {}

  virtual ~abst() = default;

  // 1つでも純粋仮想関数があれば抽象クラス
  virtual void f() = 0;
};
```

抽象クラスは未定義の純粋仮想関数を含んでいるため、オブジェクトを作成することができません。抽象クラスのオブジェクトは、その派生クラスのオブジェクトの一部としてしか存在できず、抽象クラス型はポインタとして使用することになるでしょう。

しかし、不完全型を使用可能な他の文脈では不完全型として抽象クラス型が使用される可能性があり、そのように使用された場合に後から定義を追加すると、以前はエラーの出なかった宣言が遅れてコンパイルエラーを引きおこしていました。

```cpp
struct S;

S f();   // #1、関数宣言における不完全型の使用、ok

// 数百行の後・・・

// 抽象クラスの定義、#1を遡ってエラーにする
struct S { virtual void f() = 0; };
```

このほかにも、配列の宣言などにおいても同様の事が発生します

P0929はこの問題を解決するものであり、関数や配列などの宣言の時点では抽象クラスが使用されてもそこではその抽象性をチェックせず、その関数や配列が実際に定義されたとき（あるいは関数が呼び出されたとき）に初めてチェックされコンパイルエラーが発生するようにする、というものです。

これによる恩恵はおそらく、テンプレートメタプログラミングの文脈でテンプレート実引数として抽象型が使用されたときに不要なエラーが起こらなくなるという形で得られるでしょう。

# 謝辞

本書を執筆するに当たっては以下のサイトをとても参照しました。サイト管理者及び編集者・執筆者の方々に厚く御礼申し上げます。

- cpprefjp(https://cpprefjp.github.io/ : ライセンスはCC-BY 3.0)
- cppreference(https://ja.cppreference.com/w/cpp : ライセンスはCC-BY-SA 3.0)
- yohhoyの日記(https://yohhoy.hatenadiary.jp/)

表紙は友人のKさんに書いていただきました。可愛いキノコをありがとうございました！